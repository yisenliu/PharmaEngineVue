[TOC]

# 組件註冊

---

## 組件命名

==命名規則有 2 種，結論是：使用 **kebab-case** 較不易混肴。==

- kebab-case

```js
Vue.component('my-component-name',{...})

// 在 template 內只能使用 kebab-case 組件名稱
...
template: `
  <div>
    <MyComponentName></MyComponentName> // error
    <my-component-name></my-component-name> // ok
  </div>
`
```

- PascalCase

```js
Vue.component('MyComponentName', { /* ... */ })

// 在 template 內使用下列2種組件名稱都是合法的
...
template: `
  <div>
    <MyComponentName></MyComponentName> // ok
    <my-component-name></my-component-name> // ok
  </div>
`
```

**無論採何種組件命名方式，在 HTML 內使用時都必須採 kebab-case 命名才有效。**

```html
<!-- 無效組件 -->
<MyComponentName></MyComponentName>

<!-- 有效組件 -->
<my-component-name></my-component-name>
```

## 全域註冊

全域註冊的組件可以使用在任何 `new Vue()` 實體內, 子組件內部也可以相互使用。

```js
Vue.component('component-a',{...})
Vue.component('component-b',{...})
Vue.component('component-c',{...})
new Vue({
  el: '#app'
})
```

```html
<div id="app">
  <component-a></component-a>
  <component-b>
    <component-c></component-c>
  </component-b>
</div>
```

## 局部註冊

全域註冊的組件在使用像 Webpack 打包時, 不管會不會用到, 它都會被輸出在最終的打包結果上，這會造成用戶下載的 Javascript 檔案變大。

利用簡單的 JavaScript 物件宣告方式即可建立局部註冊的組件。

```js
const componentA = {...}
const componentB = {...}

new Vue({
  el: '#app',
  components: {
    'component-a': componentA,
    'component-b': componentB,
    'component-c': {
      template: `{...}`
    }
  }
})
```

```html
<div id="app">
  <component-a></component-a>
  <component-b></component-b>
  <component-c></component-c>
</div>
```

局部註冊的組件不可直接用於同為局部註冊的組件內，但可以在子組件內宣告 `components` 以便引用其他組件：

```js
// 承上例，如果希望 component-a 在 component-c 內可用
'component-c': {
  template: `
    <div>
      <h2>Hello</h2>
      <component-sub></component-sub> // ok
      <component-a></component-a> // error
    </div>
  `,
  components: {
    'component-sub': componentA
  }
}
```

或是藉由 Babel 和 Webpack 使用 ES6 模組：

```js
import ComponentA form './ComponentA.vue'
export default {
  ...
  components: {
    ComponentA
  }
}
// 此處的 ComponentA 是 ComponentA: ComponentA 的縮寫，
// 也就是說 ComponentA 同時是 key 與 key值
```

## 模組系統

### 在模組系統局部註冊

使用 Babel 和 Webpack 模組時，建議將每個組件的文件放在 `components` 目錄內

在 `ComponentB.js` 或 `ComponentB.vue` 導入其他組件：

```js
import ComponentA from 'ComponentA.js'
import ComponentC from 'ComponentC.js'

export default {
  ...
  components: {
    ComponentA,
    ComponentC
  }
}
// 現在就可以在 ComponentB 的 Template 使用 ComponentA, ComponentC
```

# Prop

---

## Prop 的大小寫(camelCase vs kebab-case)

瀏覽器會將 HTML attribute 大寫的字元轉為小寫，因此在使用 DOM Template 時，camelCase 的 prop 需要使用 kebab-case 命名：

```js
// 在 JavaScript 內是 camelCase
Vue.component('blog-post', {
  props: ['blogTitle'],
  template: `<h2>{{ blogTitle }}</h2>`
});
```

```html
<!-- 在 HTML DOM Template 是 kebab-case -->
<blog-post post-title="Hello"></blog-post>
```

## Prop 的資料型態

如果要對 prop 指定資料型態，可以物件的方式對每一個 prop 定義：

```js
props: {
  name: String | Number | Boolean | Array | Object | Function | Promise;
}
// 當這些 prop 遇到錯誤的類型時，會在瀏覽器的控制台出現錯誤提示。
```

## 傳遞靜態或動態的 props

```html
<!-- 靜態傳遞字串：直接給值 -->
<blog-post title="This is title"></blog-post>

<!-- 動態傳遞字串：使用 v-bind 綁定-->
<blog-post v-bind:title="blog.title"></blog-post>
```

**傳遞 "非字串" 的靜態資料時，必須使用 `v-bind:prop-name="value"` 才能正確傳遞。**

```js
Vue.component('my-input', {
  props: {
    isAgree: Boolean
  },
  template: `
  <label>
    <input type="checkbox" v-model="isAgree">
    Agree
  </label>
  `
});
```

```html
<!-- 未使用 v-bind 靜態傳遞布林值(非字串)，即便值為 false， checkbox 仍會被選取(true) -->
<!-- 控制台會出現警告提示 -->
<my-input is-agree="false"></my-input>

<!-- 使用 v-bind 才能正確傳遞資料 -->
<my-input v-bind:is-agree="false"></my-input>
```

## 單向數據流

父組件可以透過 `prop` 向子組件傳遞資料，但反過來則不行。這樣的 **one-way-down binding** 設計可以避免子組件意外改變父組件的狀態，也就是說你不應該在子組件改變 `prop` 的值，這樣做會導致 Vue 在瀏覽器的控制台發出警告。

正確做法是在子組件內部**新增一個 data 屬性或使用 `computed` 處理父組件傳遞的資料**：

```js
Vue.component('my-counter', {
  props: {
    parentCount: Number,
    name: String
  },
  data: function() {
    return {
      localCount: this.parentCount
    };
  },
  computed: {
    localName: function() {
      return this.name.trim().toUpperCase();
    }
  },
  template: `
  <button v-on:click="localCount++">
    {{ localName }} clicked me {{localCount}} time
  </button>
  `
});
// 當 localCount++ 改為 parentCount++ 時，Vue 會在瀏覽器的控制台發出警告
```

```html
<my-counter v-bind:parent-count="0" name="peter jacson"></my-counter>
```

> 注意：如果父組件向子組件傳遞的資料型態是 `object` 或 `array` ，此時傳遞的是 Reference 而不是值，也就是父子組件共用同一個記憶體位置的資料，因此在子組件內更新這個資料時，會連帶改變父組件的狀態。

```html
<my-counter v-bind:parent-data="parentData"></my-counter>
<pre>{{parentData}}</pre>
```

```js
Vue.component('my-counter', {
  props: {
    parentData: Object
  },
  template: `
  <button v-on:click="parentData.count++">
    You clicked me {{parentData.count}} time
  </button>
  `
})
// 當子組件執行 parentData.count++，父組件的狀態也會更新
new Vue({
  ...
  data: {
    parentData: {
      count: 0
    }
  }
})
```

要解決這個問題，可以在子組件內使用另一組變數，以**深拷貝**的方式接收父組件傳遞的 `object` 或 `array` ：

```js
...
  props: {
    parentData: Object
  },
  data: function(){
    // 一定要用深拷貝，如果用淺拷貝也只是 copy reference
    return {
      childData: Object.assign({}, this.parentData)
    }
  },
  template: `
  <button v-on:click="childData.count++">
    You clicked me {{childData.count}} time
  </button>
  `
```

## Prop 驗證

當組件的 prop 有指定驗證要求，只要其中一個沒有通過驗證， Vue 就會在瀏覽器的控制台發出警告。

```js
Vue.component('my-component', {
  props: {
    // 基礎類型檢查 (`null` 和 `undefined` 會通過任何類型的驗證)
    propA: Number,

    // 多個可能的類型
    propB: [String, Number],

    // 必填的字串
    propC: {
      type: String,
      required: true
    },

    // 帶有預設值的數字
    propD: {
      type: Number,
      default: 123
    },

    // 帶有預設值的 Object
    propE: {
      type: Object,
      // Object 或 Array 的預設值必須藉由工廠函數取得
      default: function() {
        return { message: 'hello' };
      }
    },

    // 自定驗證函數
    propF: {
      validator: function(value) {
        // value 必須符合下列任一字串
        return ['success', 'warning', 'danger'].indexOf(value) !== -1;
      }
    }
  }
});
```

> prop 的驗證會在組件實體被創建之前進行，因此無法在 `default` 和 `validator` 函數內使用組件的屬性(如： `data`、 `computed` 等)。

## 類型檢查

`type` 可以是原生的建構函數^(1-8)^之一，也可以是自定的建構函數^(9)^，並且通過 `instanceof` 檢查確認：

1. `String`
1. `Number`
1. `Boolean`
1. `Array`
1. `Object`
1. `Date`
1. `Function`
1. `Symbol`
1. `Myconstructor`

```js
// 自定的建構函數
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

Vue.component('blog-post', {
  props: {
    author: Person // 可以驗證 author 的值是否通過 new Person() 創建的
  },
  created: function() {
    console.log(this.author instanceof Person); // true
    console.log(this.author instanceof String); // false
  },
  template: '<p>author: {{this.author.firstName}} {{this.author.lastName}}</p>'
});

new Vue({
  el: '#app',
  data: {
    man: new Person('Peter', 'Jacson'),
    // 若改為 Object，非經由 new Person() 創建，無法在子組件通過驗證
    man: { firstName: 'Nick', lastName: 'Tayler' }
  }
});
```

```html
<blog-post v-bind:author="man"></blog-post>
```

## 非 Prop 的 Attribute

它是指傳向一個組件，而該組件卻沒有對應 prop 定義的 attribute。組件可以接收任意的 attribute，而這些 attribute 會被加在組件的 root element。

例如：在組件 `<bootstrap-date-input>` 上使用了一個第三方插件，需要在 `<input>`上用到一個 `data-picker="activated"` attribute。

```js
Vue.component('bootstrap-date-input', {
  template: '<input type="date" class="form-control">'
});
```

```html
<!-- 我們可以將這個 attribute 直接加到組件實體上 -->
<bootstrap-date-input data-picker="activated"></bootstrap-date-input>

<!-- output -->
<input type="date" class="form-control" data-picker="activated" />
```

### 合併 / 替換現有的 Attribute

對大多數 attribute 而言，從組件實體上傳入的值會替換掉組件內部設定好的值。例如：傳入 `type="text"` 會替換掉原先的 `type="date"`，但 `class` 與 `style` 則會將內外部的值合併輸出。

```html
<!-- 承上例，在組件實體上新增 attribute、合併 class、替換 type -->
<bootstrap-date-input
  data-picker="activated"
  class="date-picker-theme-dark"
  type="text"
></bootstrap-date-input>

<!-- output -->
<input type="text" class="form-control date-picker-theme-dark" data-picker="activated" />
```

### 禁用 Attribute 繼承

如果不希望在組件的根元素繼承來自組件實體的 attributes，你只要在組件內部設置 `inheritAttrs: false`，配合 `v-bind="$attrs"` ，可以手動決定這些 attributes 要指定給哪個元素，在撰寫基礎組件的時候常會用到，例如：

```js
Vue.component('base-input', {
  props: {
    label: String,
    content: String
  },
  inheritAttrs: false,
  template: `
  <label>
    {{label}}
    <input type="text" 
      v-bind="$attrs" 
      v-bind:value="content" 
      v-on:input="$emit('input',$event.target.value)">
  </label>
  `
});

new Vue({
  el: '#app',
  data: {
    labelText: 'Your name',
    username: ''
  }
});
```

```html
<!-- 這種方式讓基礎組件在使用上更像原生的 HTML 元素-->
<base-input
  class="user"
  placeholder="Enter your username"
  required
  v-model="username"
  v-bind:label="labelText"
></base-input>

<!-- output -->
<label class="user">
  Your name
  <input type="text" placeholder="Enter your username" required />
</label>
```

> `inheritAttrs: false` 並不會影響 `class` 與 `style` 的綁定，這 2 個 attribute 仍會被加在組件的根元素。

# 自定義事件

---

## events 的命名

不同於 `components` 和 `props`，event 的命名不存在任何自動的大小寫轉換，而是觸發的事件必須完全符合這個事件的名稱，例如：

```js
this.$emit('myEvent'); // 事件名為 myEvent
```

```html
<!-- 使用 kebab-case 監聽這個名稱是無效的 -->
<my-component v-on:my-event="doSomething"></my-component>

<!-- 本例即便使用完全一樣的名稱也是無效的 -->
<my-component v-on:myEvent="doSomething"></my-component>
```

因為 `v-on` event listener 在 DOM template 會被自動轉為全小寫，所以 `v-on:myEvent` 會被轉為 `v-on:myevent` ，導致 `myEvent` 不可能被監聽到。

因此，**務必使用 `kebab-case` 為 event 命名**

```js
this.$emit('my-event');
```

```html
<my-component v-on:my-event="doSomething"></my-component>
```

## 自定義組件的 `v-model`

一個組件上的 `v-model` 預設會利用 `value` 的 prop 和 `input` 的 event，但是像 `radio, checkbox` 表單元件可能會將 `value` 用於其他用途，`model` 選項可以避免這樣的衝突。

```js
Vue.component('base-checkbox', {
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    checked: Boolean,
    label: String
  },
  template: `
    <label>
      <input type="checkbox"
        v-bind:checked="checked"
        v-on:change="$emit('change', $event.target.checked)>
      {{label}}
    </label>
  `
});

new Vue({
  el: '#app',
  data: {
    isAgree: true,
    label: 'I want to subscribe'
  }
});
```

```html
<base-checkbox v-model="isAgree" label="label"></base-checkbox>
```

## 將原生的 events 綁定到組件

如果想要在一個組件的根元素監聽一個原生的事件，可以在組件實體上使用 `v-on` 的 `.native` 修飾符。

```html
<base-input v-on:focus.native="onFocus"></base-input>
```

但如果 `<base-input>` 的根元素不是 `<input>`，而是 `<label>`，此時組件實體上的 `.native` listener 將會失效( `onFocus` 不會被執行)，也不會出現任何錯誤訊息。

為了解決這個問題，Vue 提供了 `v-on="$listeners"` 將所有的 event listeners 指向這個組件內的特定元素，如果要結合 `v-model`，可以創建一個如下的 `inputListeners` 計算屬性：

```js
Vue.component('base-input', {
  inheritAttrs: false,
  props: {
    label: String,
    value: [String, Number, Date]
  },
  computed: {
    inputListeners: function() {
      const vm = this;
      return Object.assign(
        {},
        // 從父組件添加所有的 listeners
        this.$listeners,
        // 添加一些自定義的 listeners 或覆寫一些 listeners 的行為
        {
          input: function(event) {
            vm.$emit('input', event.target.value);
          }
        }
      );
    }
  },
  template: `
  <label>
    {{label}}
    <input v-bind="$attrs" v-bind:value="value" v-on="inputListeners">
  </label>
  `
});

new Vue({
  el: '#app',
  data: {
    value: ''
  },
  methods: {
    onInput: function(value, event) {
      console.log(value, event.type);
    }
  }
});
```

```html
<base-input
  label="Name"
  placeholder="Enter your name"
  type="text"
  v-on:input="onInput"
  v-model="value"
></base-input>
```

## `.sync` 修飾符

**簡而言之，就是 "One way data flow" 模式的縮寫。**
有些時候我們需要對一個 prop 進行雙向綁定，但真正的雙向綁定(由子組件直接修改父組件傳入的 prop )會帶來維護上的問題，所以才會推薦以 `update:myPropName` 的方式觸發 event 來取代。(作法類似`$emit('event-name', newValue)`，差別在於要指定用 `update:myPropName` 作為 event-name。)

![One way data flow](https://d1dwq032kyr03c.cloudfront.net/upload/images/20180105/20107673f0zb0ZxRz9.png)

```js
// 子組件向父組件發送 event
this.$emit('update:title', newTitle);
```

```html
<!-- 當父組件觸發該 event 時，更新資料 -->
<text-document v-bind:title="doc.title" v-on:update:title="doc.title = $event"></text-document>

<!-- 為了方便起見，Vue 為這種模式提供縮寫，即為 .sync 修飾符-->
<text-document v-bind:title.sync="doc.title"></text-document>
```

> 帶有`.sync`修飾符的 `v-bind` 不能與表達式一起使用，例如：`v-bind:title.sync="doc.title + '!'"` 是無效的，你只能提供想要綁定的屬性名。

使用 `v-bind.sync="objectName"` 就可以將 objectName 內的所有 prop 傳入子組件 ：

```html
<text-document v-bind.sync="doc"></text-document>
```

```js
Vue.component('text-document', {
  props: {
    title: String,
    desc: String
  },
  template: `
  <div>
    <h3>{{title}}</h3>
    <button v-on:click="$emit('update:title', 'title is changed')">Change title</button>
    <p>{{desc}}</p>
    <button v-on:click="$emit('update:desc', 'desc is changed')">Change desc</button>
  </div>
  `
}

new Vue({
  el: '#app',
  data: {
    doc: {
      title: 'Hello',
      desc: 'initial desc'
    }
  }
})
```

# 插槽 `slot`

---

## 插槽內容

```js
// 宣告一個帶有 slot 的組件
Vue.component('navigation-link', {
  props: ['url'],
  template: `
  <a v-bind:href="url">
    <slot></slot>
  </a>
  }
  `
});
```

```html
<navigation-link url="link1.html">
  <!-- 此處即為`插槽內容`，
  組件內的 <slot></slot> 會被替換為 Link One -->
  Link One
</navigation-link>
```

> 如果 `<navigation-link>` 組件內部沒有包含 `<slot>`，所有在這個組件`<navigation-link>...</navigation-link>` 之間的內容都會被忽略。

## 編譯作用域

> **父組件的所有內容都是在父級作用域中編譯的；子組件的所有內容都是在子級作用域中編譯的。**

在插槽內使用父級模板的資料：

```html
<navigation-link url="link1.html">
  Logged in as {{user.name}}
</navigation-link>
```

```js
...
data: {
  user: {
    name: 'Peter'
  }
}
```

在父級的作用域無法使用子級的屬性：

```html
<navigation-link url="link1.html">
  <!-- `{{url}}` 會是 undefined ，因為它不是父級的屬性 -->
  Clicking here will send you to: {{ url }}
</navigation-link>
```

## 預設內容

插槽可以指定一個預設內容，以便在沒有提供內容時被引用：

```js
// 宣告一個 <submit-button> 組件
Vue.component('submit-button', {
  template: `
  <button type="submit">
    <slot>Submit</slot>
  </button>
  `
});
```

```html
<submit-button></submit-button>
<!-- 輸出：<button type="submit">Submit</button> -->

<submit-button>Save me</submit-button>
<!-- 輸出：<button type="submit">Save me</button> -->
```

## 具名插槽

如果組件內有多個插槽，需要使用 `name` 對每一個插槽命名，語法為 `<slot name="slotName"></slot>`

```js
// 未命名的插槽會使用預設名稱 `default`，相當於 name="default"
Vue.component('base-layout', {
  template: `
  <div class="container">
    <header>
      <slot name="header"></slot>
    </header>
    <main>
      <slot></slot>
    </main>
    <footer>
      <slot name="footer"></slot>
    </footer>
  </div>
  `
});
```

在向具名插槽提供內容時，可以在一個 `<template>` 元素上使用 `v-slot` 指令，格式為 `<template v-slot:slotName>`

```html
<base-layout>
  <template v-slot:header>
    <h1>This is Header</h1>
  </template>

  <!-- 所有未指定插槽的內容都會被視為預設插槽的內容 -->
  <p>A paragraph for the main content.</p>
  <p>And another one.</p>
  <!-- 相當於下列語法 -->
  <template v-slot:default>
    <p>A paragraph for the main content.</p>
    <p>And another one.</p>
  </template>

  <template v-slot:footer>
    <p>This is Footer</p>
  </template>
</base-layout>
```

注意，==`v-slot`只能套用在 `<template>` 上，但有一種例外：父級所提供的內容只有預設插槽時，`v-slot` 才可以直接添加在子組件標籤上。==

### 縮寫

`v-slot:` 可以替換為 `#`，例如：`v-slot:header` 可縮寫為 `#header`。

注意：==`#`後面必須帶有明確的插槽名稱，即便是 default 插槽也不例外。==

上例可改寫為：

```html
<base-layout>
  <template #header>
    ...
  </template>
  <!-- default 插槽也不例外 -->
  <template #default>
    ...
  </template>
  <template #footer>
    ...
  </template>
</base-layout>
```

縮寫的具名插槽與作用域插槽同時使用：

```html
<!-- error -->
<current-user #="{user}">
  {{user.firstName}
</current-user>

<!-- correct -->
<current-user #default="{user}">
  {{user.firstName}
</current-user>
```

## 作用域插槽

> 目的：
> 在父組件的插槽內容讀取子組件的資料，進而建立有別於子組件 `template` 的不同結構。

在作用域的規則下，無法直接在父組件上使用子組件的屬性，為了在父組件的插槽內容能夠讀取子組件的資料，需要在子組件的 `<slot>` 綁定一個或多個 prop (==物件型態==)，稱為 **slot props**：

```js
// 宣告一個 <current-user> 組件
Vue.component('current-user', {
  data: function() {
    return {
      user: {
        firstName: 'Peter',
        lastName: 'Jacson'
      },
      favirate: {
        color: 'red',
        drink: 'tea'
      }
    };
  },
  // 在 <slot> 綁定一個或多個屬性，讓父組件讀取
  template: `
  <div>
    <slot v-bind:my-user="user" v-bind:my-favirate="favirate">
      {{user.firstName}} {{user.lastName}} loves {{favirate.color}} color and drink {{favirate.drink}}.
    </slot>
  </div>
  `
});
```

```html
<current-user>
  <!-- `slotProps` 代表所有綁定在具名或預設插槽上的屬性，可任意命名 -->
  <template v-slot:default="slotProps">
    <h3>
      {{slotProps.myUser.firstName}} {{slotProps.myUser.lastName}}
    </h3>
    <ul>
      <li v-for="(value,key,index) in slotProps.myFavirate" v-bind:key="index">
        {{key}}: {{value}}
      </li>
    </ul>
  </template>
</current-user>
```

> 如果子組件 data 內含有非物件型態的屬性(如：字串)，可使用 `<slot v-bind:my-data="$data">` 綁定所有 data ，或使用 `<slot v-bind:my-data="{name: name, age: age}">` 綁定特定 data。

### 獨佔預設插槽的縮寫語法

在上例中，當父組件的插槽內容只有一個插槽時 (通常為沒有命名的預設插槽)，`v-slot` 才可以直接套用在子組件標籤上，不需要再添加 `<template>`：

```html
<!-- 原先語法 -->
<current-user>
  <template v-slot:default="slotProps">
    ...
  </template>
</current-user>

<!-- 縮寫語法，將 v-slot:default 寫在組件標籤上；
v-slot:default="..."可再縮寫為 v-slot="..." -->
<current-user v-slot="slotProps">
  ...
</current-user>
```

注意：**預設插槽的縮寫語法不能與具名插槽混用，會導致作用域不明確。**

```html
<current-user v-slot="slotProps">
  ...
  <template v-slot:other="otherSlotProps">
    <!-- slotProps 在此處無法使用 -->
    {{ slotProps.user.firstName }}
  </template>
</current-user>
```

==**當使用多個插槽時，請為所有的插槽使用完整的`<template v-slot:slotName>`語法。**==

```html
<current-user>
  <template v-slot:default="slotProps">
    ...
  </template>
  <template v-slot:other="otherSlotProps">
    ...
  </template>
  <template v-slot:static>
    ...
  </template>
</current-user>
```

### 解構 Slot Props

作用域插槽的內部工作原理是將父級的插槽內容放入一個含有單一參數的函數內：

```js
function(slotPros){
  // 插槽內容
}
```

這意味著 `v-slot` 的值可以是任何能夠作為函數定義中的參數的 JavaScript 表達式，可以使用 [ES6 解構](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E8%A7%A3%E6%9E%84%E5%AF%B9%E8%B1%A1) 來傳入具體的 slot props：

```html
<!-- 解構 slotProps 之後，插槽內容更簡潔 -->
<current-user v-slot="{user}">
  {{user.firstName}}
</current-user>
```

這樣可以使插槽內容更簡潔，甚至可以為 prop 重新命名：

```html
<current-user v-slot="{user: person}">
  {{person.firstName}}
</current-user>
```

## 動態插槽名稱

如同 `v-bind:[argument]` ， `v-slot`也可以使用**動態參數**定義動態的插槽名稱，同樣==必須採用全小寫==：

```html
<base-layout>
  <template v-slot:[dynamicslotname]>
    ...
  </template>
</base-layout>
```

### 範例

使用一個 `<todo-list>` 作為子組件，並在父級的插槽內容改寫為：可依據內部每一項工作是否完成而有不同標示。

```js
Vue.component('todo-list', {
  props: {
    todos: Array
  },
  template: `
  <ul>
    <li v-for="todo in todos" v-bind:key="todo.id">
      <slot v-bind:todo="todo">
        // 預設值
        {{todo.text}}
      </slot>
    </li>
  </ul>
  `
});

new Vue({
  el: '#app',
  data: {
    list: [
      { id: 1, text: 'Todo One', done: false },
      { id: 2, text: 'Todo Two', done: true },
      { id: 3, text: 'Todo Three', done: false }
    ]
  },
  computed: {
    filteredList: function() {
      // 排序陣列，將已完成的項目放後面
      return this.list.sort(function(a, b) {
        let x = a.done ? 1 : 0;
        let y = b.done ? 1 : 0;
        return x - y;
      });
    }
  }
});
```

```html
<todo-list v-bind:todos="filteredList" #default="{todo}">
  <span v-if="todo.done" :class="{done: todo.done}">
    {{todo.text}}
  </span>
  <template v-else>{{todo.text}}</template>
</todo-list>
```

# 動態組件 & 非同步組件

---

## 在動態組件上使用 `keep-alive`

在先前的 Tabs 範例使用`:is`來切換不同的組件

```html
<component v-bind:is="currentTabComponent"></component>
```

當這些動態組件切換時，無法保持這些組件的狀態，Vue 會在每一次切換組件時，重新渲染一個新的 `currentTabComponent` 實體，為了避免反復切換組件所造成的渲染性能問題，同時緩存每個組件的狀態，可以使用 `<keep-alive>` 將動態組件包起來。

```html
<keep-alive>
  <component v-bind:is="currentTabComponent"></component>
</keep-alive>
```

> `<keep-alive>`要求被切換到的組件都必須有自己的名字，無論是使用組件的`name`或是全域/局部註冊。

## 非同步組件

Vue 允許用一個工廠函數定義組件，只有在這個組件需要被渲染的時候才會觸發該函數，並且會把結果緩存起來，以便重複使用。

```js
Vue.component('async-component', function(resolve, reject) {
  // 向 resolve callback 傳遞組件定義
  // 你可以呼叫 reject(reason) 來表示載入失敗
  resolve({
    template: '<div>I amd async.</div>'
  });
});
```

如何取得組件定義取決於你自己，一個==推薦的做法是將**非同步組件**與 **Webpack code-splitting** 配合使用==：

```js
// CommonJS
Vue.component('my-component', function(resolve) {
  require(['./my-async-component'], resolve)
})

// 或是使用 ES6 的語法在工廠函數中返回一個 `Promise`
Vue.component(
  'my-component',
  // 這個 import() 會返回一個 `Promise` Object
  () => import('./my-async-component')
)

// 局部組件也可以使用函數返回一個 `Promise` Object
new Vue({
  ...
  components: {
    'my-component': () => import('./my-async-component')
  }
})
```

### 處理載入狀態

非同步組件工廠函數也可以返回一個如下格式的物件：

```js
const AsyncComponent = () => ({
  // The component to load (should be a Promise)
  component: import('./MyComponent.vue'),
  // A component to use while the async component is loading
  loading: LoadingComponent,
  // A component to use if the load fails
  error: ErrorComponent,
  // Delay before showing the loading component. Default: 200ms.
  delay: 200,
  // The error component will be displayed if a timeout is
  // provided and exceeded. Default: Infinity.
  timeout: 3000
});
```

# 處理邊界情況

---

> 這裡記錄的都是和處理邊界情況有關的功能，也就是一些需要對 Vue 的規則做出小調整的特殊情況。==但這些功能都有壞處或是存在危險性==，所以當你使用這些功能時要多加注意。

## 元素與組件的存取

==在多數情況下，最好不要觸達組件實體內部或手動操作 DOM 元素。==

### 存取根實體 (`this.$root`)

在每個`new Vue()`根實體的子組件中，可以透過`this.$root`存取根實體。例如：

```js
// Vue Instance
new Vue({
  ...
  data: {
    foo: 1
  },
  computed: {
    bar: function(){...}
  },
  methods: {
    show: function(){...}
  }
})
```

所有子組件都可以使用`this.$root`存取根實體：

```js
// 讀取根實體的資料
const a = this.$root.foo;

// 寫入根實體的資料
this.$root.foo = 2;

// 取得根實體的計算屬性
const b = this.$root.bar;

// 執行根實體的方法
this.$root.show();
```

==在多數情況下，強烈建議使用 Vuex 來管理組件的狀態。==

### 存取父組件實體 (`this.$parent`)

和`$root`類似，`$parent`屬性可以讓子組件存取父組件的實體，它可以在後期隨時觸達父組件，以替代利用 `prop`將資料傳入子組件的方式。

==在多數情況下，使用`$parent`觸達父組件會讓你的程式更難除錯與理解，尤其在你變更了父組件的資料，又經過一段時間回頭看這個組件時，很難找出是哪個環節對資料作了變動。==

```html
<!-- <google-map-markers> 可以使用 this.$parent.getMap() 取得全部地圖 -->
<google-map>
  <google-map-markers v-bind:places="iceCreamShops"></google-map-markers>
</google-map>

<!-- <google-map-markers> 同樣使用 this.$parent.getMap() 卻只能取得部份地圖 -->
<google-map>
  <google-map-region v-bind:shape="cityBoundaries">
    <google-map-markers v-bind:places="iceCreamShops"></google-map-markers>
  </google-map-region>
</google-map>
```

它很快就會失控，所以針對任意層級的組件提供上下文訊息時，Vue 建議使用**依賴注入 (Dependency injection)**。

### 存取子組件實體與子元素

父組件雖然可以使用 **One way data flow** 的方式 (亦即 **Props Down, Events Up**) 存取子組件，但有時候你仍然需要在 JavaScript 裡直接存取子組件實體，此時可以使用`ref`賦予子組件一個 ID：

```html
<base-input ref="usernameInput"></base-input>
```

現在可以在父組件使用`$refs`來存取`<base-input>`實體，以便不時之需。：

```js
this.$refs.usernameInput;
```

在`<base-input>`組件內的元素也可以使用`refs`供內部存取，進而由父組件間接控制：

```js
// 對子組件元素設定 ref，定義 methods
template: '<input ref="textInput">',
methods: {
  focus: function(){
    this.$refs.textInput.focus();
  }
}

// 父組件就能使用下列程式碼聚焦子組件<base-input>的輸入框
this.$refs.usernameInput.focus();
```

完整程式碼：

```html
<base-input v-bind:data="user" v-model="user.value" ref="usernameInput"></base-input>
<button v-on:click="focusInput">Focus Input</button>
```

```js
Vue.component('base-input', {
  props: {
    data: Object
  },
  template: `
  <label>
    {{data.label}}
    <input type="text" :placeholder="data.placeholder" :value="data.value" v-on:input="$emit('input', $event.target.value)" ref="textInput">
  </label>
  `,
  methods: {
    focus: function() {
      this.$refs.textInput.focus();
    }
  }
});

new Vue({
  el: '#app',
  data: {
    user: {
      label: 'Username',
      value: '',
      placeholder: 'Enter your name'
    }
  },
  methods: {
    focusInput: function() {
      this.$refs.usernameInput.focus();
    }
  }
});
```

==`$refs`只會在組件渲染完成之後生效，而且他們不是響應式的，這只能做為直接操作子組件的 "逃生艙"，你應該避免在 templates 和 computed 屬性中使用它。==

例如，將上例`<base-input>`的`focus()`改寫如下：

```js
focus: function() {
  // 改寫 this.$refs.textInput.focus()
  this.$refs.textInput.value = 'abc'
  // 使用 $refs 變更了 template 內的輸入框的值
}
```

當按下`button`按鈕，雖然輸入框的值變成 abc，但根實體的資料並沒有改變。

### 依賴注入

```html
<google-map>
  <google-map-region v-bind:shape="cityBoundaries">
    <google-map-markers v-bind:places="iceCreamShops"></google-map-markers>
  </google-map-region>
</google-map>
```

在這個組件裡，所有的`<google-map>`後代都需要存取一個`getMap`的方法，以便知道要跟哪個地圖互動。但是使用`$parent`並無法很方便的擴展到更深層級的子組件上，這就是為何要使用**依賴注入**的原因，它提供了 2 種實體選項：`provide`和`inject`。

`provide`允許我們指定要提供給後代組件的資料或方法，在本例中，就是`<google-map>`內部的`getMap`方法。

```js
// 父級組件
provide: function(){
  return {
    getMap: this.getMap
  }
}
```

然後在任何後代組件內，我們可以使用`inject`選項來接收想要添加在這個組件實體的特定屬性：

```js
// 後代組件
...
inject: ['getMap'],
created: function(){
  this.getMap(...)
},
...
```

相較於`$parent`，這個用法可以讓我們在任何後代組件中使用`getMap`，而不用曝露整個`<google-map>`實體。這對組件的擴充/縮減提供了很好的彈性，因為：

- 祖先組件不需要知道哪些後代組件使用了它提供的屬性
- 後代組件不需要知道被注入的屬性來自哪裡

==然而，依賴注入是有負面影響的，它將應用程式中的眾多組件耦合起來，使重構變得更加困難。同時所提供的屬性不是響應式的，這是出於設計的考量，因為使用它們或`$root`來創建一個中心化、規模化的資料都是不夠好的。如果你想要共用的這個屬性是你的應用程式特有的，而不是通用化的，或者你想在祖先組件中更新所提供的資料，應該使用像`Vuex`這樣真正的狀態管理方案。==

## 程式化的 Event Listeners

在組件內使用`$emit`，可以被`v-on`監聽，但是 Vue instance 同時在其 events interface 中提供了其他方法：

- `$on(eventName, eventHandler)`監聽一個事件
- `$one(eventName, eventHandler)`一次性監聽一個事件
- `$off(eventName, eventHandler)`停止監聽一個事件

通常不需要使用這些方法，但是當你需要在一個組件實體上手動監聽事件時就用得上，==經常應用在需要結合 3rd-party plugin 一起使用的場合。==
例如：一次性的將 `Pikaday` 日期選擇器套用在輸入框上

```html
<div id="app">
  Input Date
  <input type="text" ref="dateInput" />
</div>
```

```js
// 目標：
new Vue({
  el: '#app',
  mounted: function() {
    this.picker = new Pikaday({
      field: this.$refs.dateInput
    })
  },
  ...
  // 組件被銷毀之前，先銷毀日期選擇器
  beforeDestroy: function() {
    this.picker.destroy()
  }
})
```

這樣的寫法有 2 個潛在問題：

1. `picker`會被保存在這個組件實體中，但==最好是只讓 lifecycle hooks 存取它。==
1. 建立`new Pikaday()`與銷毀`destroy()`的程式碼是分開的，這會讓我們很難有效的清理這些程式碼。

透過程式化的監聽器可以解決這 2 個問題：

```js
new Vue({
  el: '#app',
  mounted: function() {
    const picker = new Pikaday({
      field: this.$refs.dateInput
    });
    this.$once('hook:beforeDestroy', function() {
      picker.destroy();
    });
  }
});
```

使用這個策略，就可以把這些指令包裝起來，讓其他輸入框可以同時使用這個套件：

```js
mounted: function(){
  this.attachDatepicker('startDateInput');
  this.attachDatepicker('endDateInput');
},
methods: {
  attachDatepicker: function(refName){
    const picker = new Pikaday({
      field: this.$refs[refName]
    });
    this.$once('hook:beforeDestroy', function() {
      picker.destroy()
    })
  }
}
```

==注意，如果你發現自己不得不在同一個組件裡做很多建立與銷毀的工作，最好的方式是建立一個可以重複使用的模組化組件。==

```html
<div id="app">
  <input-datepicker v-bind:date="startDate" v-model="startDate.value"></input-datepicker>
  <input-datepicker v-bind:date="endDate" v-model="endDate.value"></input-datepicker>
</div>
```

```js
Vue.component('input-datepicker', {
  model: {
    event: 'change'
  },
  props: {
    date: Object
  },
  mounted: function() {
    const picker = new Pikaday({
      field: this.$refs.dateInput
    });
    this.$once('hook:beforeDestroy', function() {
      picker.destroy();
    });
  },
  template: `
    <div>
      <label>
        {{date.label}}
        <input type="text" ref="dateInput" v-bind:value="date.value" v-on:change="$emit('change',$event.target.value)">
      </label>
    </div>
  `
});

new Vue({
  el: '#app',
  data: {
    startDate: {
      label: 'From',
      value: ''
    },
    endDate: {
      label: 'To',
      value: ''
    }
  }
});
```

> Vue 的 events 不同於瀏覽器的 EventTarget API，也就是說`$emit`、`$on`和`$off`並不是`dispatchEvent`、`addEventListener`和`removeEventListener`的別名。

## 循環引用

### 遞迴組件

組件可以在自己的`template`內調用自己，但只能透過`name`選項來調用：

```js
name: 'my-component';
```

當你使用全域註冊一個組件時，這個全域的 ID 就會自動成為該組件的`name`選項：

```js
Vue.component('my-component',{...})
```

==稍有不慎，遞迴組件可能會導致無窮迴圈：==

```js
// 會導致 `max stack size exceeded` 的錯誤
Vue.component('my-conponent', {
  name: 'stack-overflow',
  template: '<div><stack-overflow></stack-overflow></div>'
});
```

==必須確保遞迴調用是有條件性的，例如使用一個最終會得到`false`的`v-if`。==

### 組件之間的循環引用

假設你要建立一個類似檔案總管那樣的目錄結構，你可能會有 2 個組件`<tree-folder>`和`<tree-folder-contents>`如下：

```js
// <tree-folder> 組件
Vue.component('tree-folder', {
  props: {
    folder: Object
  },
  template: `
    <div>
      <span>{{folder.name}}</span>
      <tree-folder-contents v-bind:children="folder.children"></tree-folder-contents>
    </div>
  `
});

// <tree-folder-content> 組件
Vue.component('tree-folder-contents', {
  props: {
    children: Array
  },
  template: `
    <ul>
      <li v-for="(child, index) in children" v-bind:key="index">
        <tree-folder v-if="child.children" v-bind:folder="child"></tree-folder>
        <span v-else>{{child.name}}</span>
      </li>
    </ul>
  `
});
```

如果使用上述`Vue.component`全域註冊組件的時候，這樣做沒問題。但如果使用打包工具，例如： Webpack 或 Browserify，會遇到一個錯誤：

```
Failed to mount component: template or render function not defined.
```

因為這 2 個組件互相依賴變成一個循環，不知由誰開始，所以我們可以先設定一個起始點`<tree-folder>`，再利用該組件的生命週期鉤子去註冊`<tree-folder-contents>`組件：

```js
beforeCreate: function () {
  this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue').default
}
```

或在局部註冊時使用 Webpack 的動態`import`：

```js
components: {
  TreeFolderContents: () => import('./tree-folder-contents.vue');
}
```

## Template 定義的替代品

### `inline-template`

當一個子組件上面出現`inline-template`這個特殊的 attribute 時，這個組件將會使用裡面的內容作為 `template`，而不是將它視為分派的內容，這使得 template 的撰寫工作變得更加靈活。

```js
Vue.component('cart', {
  props: ['list'],
  template: `
    <ul>
      <li v-for="(item, index) in list" v-bind:key="index">{{item}}</li>
    </ul>
  `
});

new Vue({
  el: '#app',
  data: {
    list: ['A', 'B', 'C']
  }
});
```

```html
<div id="app">
  <!-- 即便綁定 prop 也沒用 -->
  <cart inline-template v-bind:list="list">
    <!-- inline-template 要定義在 Vue 所屬的 DOM 元素內-->
    <p>123</p>
    <p></p
  ></cart>
</div>
```

輸出結果：

```html
<p>123</p>
```

==但是，`inline-template`會讓作用域變得更加難以理解，所以最好還是在組件內使用`template`選項或`.vue`文件內的`<template>`元素來定義模板。==

### `x-template`

另一個定義 template 的方法是在一個`<script>`元素內加上`type="text/x-template"`，再設定一個`id`以便引用：

```html
<div id="app">
  <!-- x-template 要定義在 Vue 所屬的 DOM 元素內-->
  <script type="text/x-template" id="hello-world-template">
    <div>Hello World</div>
  </script>
  <hello-world></hello-world>
</div>
```

```js
Vue.component('hello-world', {
  template: '#hello-world-template'
});
```

==適用於 template 特別大的應用，但其它情況下應避免使用，因為它會將 template 與組件的其他定義分開。==

## 控制更新

正常來說，Vue 的響應式系統會知道資料何時應該更新。

### 強制更新

==如果你發現自己需要在 Vue 中做一次強制更新，99.9%的情況是你在某個地方做錯了。==

### 使用`v-once`建立低開銷的靜態組件

有些組件包含了大量的靜態內容，你可以在 template 的根元素加上`v-once`，以確保這些內容只會計算一次然後被緩存起來：

```js
Vue.component('terms-of-service', {
  template: `
    <div v-once>
      <h2>Terms of Service</h2>
      ...
    </div>
  `
});
```

==除非你發現渲染明顯變慢了，否則根本不需要使用這個模式；再者，如果別的開發者不熟悉`v-once`或漏看了這個屬性，他們可能會花很多時間才能找出這個 template 為何無法正常更新。==
