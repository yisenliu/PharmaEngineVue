[TOC]

# 進入 / 離開 & 列表過渡

---

## 概述

Vue 在插入、更新或移除 DOM 時，提供了以下方式處理過渡效果：

- 對 CSS transitions and animations 自動套用 class
- 在 transition hooks 中使用 JavaScript 直接操作 DOM
- 整合第三方 CSS animation library，例如：Animate.css
- 整合第三方 JS animation library，例如：Velocity.js

## 單元素 / 組件的過渡

Vue 提供了`transition`的封裝組件，在下列情形中，可以給任何元素或組件添加進入/離開過渡：

- 使用`v-if`的元素或組件
- 使用`v-show`的元素或組件
- 動態組件
- 組件的根節點

典型的例子如下：

```html
<div id="app">
  <button v-on:click="show = !show">Toggle</button>
  <transition name="fade">
    <p v-if="show">Hello</p>
  </transition>
</div>
```

```js
new Vue({
  el: '#app',
  data: {
    show: true
  }
});
```

```css
.fade-enter,
.fade-leave-to {
  opacity: 0;
}

.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.4s;
}
```

當一個被包在`<transition>`組件中的元素被插入/刪除時，Vue 會做以下處理：

1. 自動嗅探目標元素是否應用了 CSS 過渡/動畫，如果有的話就在適當時機添加/刪除 Class Name。
1. 如果過渡組件提供了 [JavaScript 鉤子函數](https://cn.vuejs.org/v2/guide/transitions.html#JavaScript-%E9%92%A9%E5%AD%90)，這些鉤子函數將在適當時機被呼叫。
1. 如果沒有檢測到 CSS 過渡/動畫，也沒有提供 JavaScript 鉤子函數，DOM 的插入/刪除會在下一格立刻執行。

### 過渡的類名

在進入/離開的過渡中，會有 6 個 class 切換：

1. `v-enter`
   Starting state for enter.
   在元素被插入之前生效，被插入之後的下一格移除。
1. `v-enter-active`
   Active state for enter.
   在整個進入過渡的階段中應用，在元素被插入之前生效，在過渡/動畫完成之後移除，用於定義 css transition 的各項屬性(property, duration, delay, time-function)。
1. `v-enter-to`
   Ending state for enter.
   在元素被插入的下一格生效 (此時`v-enter`被移除)，在過渡/動畫完成之後移除。
1. `v-leave`
   Starting state for leave.
   在離開過渡被觸發時立刻生效，下一格被移除。
1. `v-leave-active`
   Active state for leave.
   在整個離開過渡的階段中應用，在離開過渡被觸發時立刻生效，在過渡/動畫完成之後移除，用於定義 css transition 的各項屬性(property, duration, delay, time-function)。
1. `v-leave-to`
   Ending state for leave.
   在離開過渡被觸發後的下一格生效， (此時`v-leave`被移除)，在過渡/動畫完成之後移除。

![enter/leave classes](https://cn.vuejs.org/images/transition.png)

對於這些在過渡中切換的 class 來說，如果你使用一個沒有命名的 `<transition>`，則`v-`會是這些 class 的預設前綴字，如果你使用了`<transition name="fade">`，`v-enter`會替換為`fade-enter`，其他 class 依此類推。

### CSS 過渡

常用的過渡都是使用 CSS 過渡。

### CSS 動畫

CSS 動畫的用法同 CSS 過渡，兩者的區別是在 CSS 動畫中`v-enter`不會在元素被插入後立刻移除，而是在`animationend` event 觸發時移除。

例子：

```html
<div id="app">
  <button v-on:click="show = !show">Toggle</button>
  <transition name="bounce">
    <p v-if="show">Hello</p>
  </transition>
</div>
```

```css
.bounce-enter,
.bounce-leave {
  transform-origin: left center;
}
.bounce-enter-active {
  animation: bounce-in 0.4s;
}
.bounce-leave-active {
  animation: bounce-in 0.4s reverse;
}
@keyframes bounce-in {
  0% {
    transform: scale(0);
  }
  50% {
    transform: scale(1.2);
  }
  100% {
    transform: scale(1);
  }
}
```

### 自定義過渡的類名

我們可以使用以下 attribute 自定義過渡的類名：

- `enter-class`
- `enter-active-class`
- `enter-to-class`
- `leave-class`
- `leave-active-class`
- `leave-to-class`

這些 attributes 的優先權高於先前提到的 6 個 class names，當你想要結合 Vue 的過渡系統與第三方 CSS Animation Library (如：Animate.css) 時非常有用。

範例：

```html
<link
  rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css"
/>

<div id="app">
  <button v-on:click="show = !show">Toggle</button>
  <transition enter-active-class="animated bounceIn" leave-active-class="animated bounceOut">
    <p v-if="show">Lorem ipsum dolor sit amet, consectetur adipisicing elit.</p>
  </transition>
</div>
```

```js
new Vue({
  el: '#app',
  data: {
    show: true
  }
});
```

### 同時使用過渡與動畫

Vue 為了知道過渡或動畫的完成，必須設置對應的 event listeners。它可以是`transitionend`或`animationend`，這取決於 CSS 的規則。如果你只使用其中一種，Vue 能自動識別類型並設置正確的 event listeners。

但是在一些場景中，你需要對同一元素同時設置過渡與動畫，此時可能會遇到：`transition`與`animation`其中一個效果完成了，但另一個效果還沒結束，在這種情況下，你需要使用 attribute `type="animation | transition"`來明確告訴 Vue 需要監聽的類型。

```html
<transition type="animation | transition">
  ...
</transition>
```

### 明確的過渡持續時間

在多數情況下，Vue 可以得出過渡/動畫效果的完成時機。Vue 預設會等待`<transition>`組件下的根元素的第一個`transitionend`或`animationend` event。但如果是一連串複雜的過渡/動畫效果，內部元素可能比根元素有更長或延遲的效果時，可以在`<transition>`加上`:duration`指定效果的持續時間(以毫秒計)。

```html
<!-- 進入/離開的持續時間相同 -->
<transition :duration="1000">...</transition>

<!-- 進入/離開的持續時間不同 -->
<transition :duration="{enter: 500, leave: 800}">...</transition>
```

### JavaScript 鉤子

可以在`<transition>`定義的 8 個 JavaScript Hooks：

- `v-on:before-enter`
- `v-on:enter`
- `v-on:after-enter`
- `v-on:enter-cancelled`
- `v-on:before-leave`
- `v-on:leave`
- `v-on:after-leave`
- `v-on:leave-cancelled`

```html
<transition
  v-on:before-enter="beforeEnter"
  v-on:enter="enter"
  v-on:after-enter="afterEnter"
  v-on:enter-cancelled="enterCancelled"
  v-on:before-leave="beforeLeave"
  v-on:leave="leave"
  v-on:after-leave="afterLeave"
  v-on:leave-cancelled="leaveCancelled"
>
  ...
</transition>
```

```js
// ...
methods: {
  // --------
  // Entering
  // --------
  beforeEnter: function(el){
    //...
  },
  // 當與 CSS 結合使用時，callback 函數 done 是選用的
  enter: function(el, done){
    // ...
    done()
  },
  afterEnter: function(el){
    //...
  },
  enterCancelled: function(el){
    // ...
  },

  // --------
  // Leaving
  // --------
  beforeLeave: function(el){
    // ...
  },
  // 當與 CSS 結合使用時，callback 函數 done 是選用的
  leave: function(el, done){
    // ...
    done()
  },
  afterLeave: function(el){
    // ...
  },
  // leaveCancelled 只能用於 v-show 中
  leaveCancelled: function(el){
    // ...
  }
}
```

這些鉤子函數可以結合 CSS `transitions/animations`使用，也可以單獨使用。

==在單獨使用 JavaScript 過渡時，**在`enter`和`leave`中必須使用 `done` callback**==，否則，它們將被同步調用，過渡會立刻完成。

==建議針對單獨使用 JavaScript 過渡的元素明確加上`v-bind:css="false"`==,Vue 會跳過 CSS 檢測，這也可以避免過渡過程中受到 CSS 的影響而發生意外。

一個使用 gsap.js 的例子：

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.0.5/gsap.min.js"></script>
<div id="app">
  <button @click="show = !show">Toggle</button>
  <transition
    v-bind:css="false"
    v-on:before-enter="beforeEnter"
    v-on:enter="enter"
    v-on:leave="leave"
  >
    <p v-if="show">Hello</p>
  </transition>
</div>
```

```js
new Vue({
  el: '#app',
  data: {
    show: false
  },
  methods: {
    beforeEnter: function(el) {
      el.style.transformOrigin = 'left top';
    },
    enter: function(el, done) {
      gsap.to(el, {
        x: 30,
        scale: 1.4,
        ease: 'elastic-out',
        duration: 0.8,
        onComplete: done
      });
    },
    leave: function(el, done) {
      const tl = gsap.timeline();
      tl.to(el, {
        rotationZ: 100,
        repeat: 2,
        yoyo: true,
        ease: 'power1.inOut',
        duration: 0.4
      }).to(el, {
        rotationZ: 45,
        y: 30,
        x: 30,
        opacity: 0,
        duration: 0.4,
        onComplete: done
      });
    }
  }
});
```

## 初始渲染的過渡

在`<transition>`設置`appear` attribute 可以定義節點在初始渲染的過渡。

```html
<transition appear>
  <!-- ... -->
</transition>
```

自定 CSS classname

```html
<transition
  appear
  appear-class="custom-appear-class"
  appear-to-class="custom-appear-to-class"
  appear-active-class="custom-appear-active-class"
>
  <!-- ... -->
</transition>
```

JavaScript Hooks

```html
<transition
  appear
  v-on:before-appear="onBeforeAppear"
  v-on:appear="onAppear"
  v-on:after-appear="onAfterAppear"
  v-on:appear-cancelled="onAppearCancelled"
>
  <!-- ... -->
</transition>
```

無論是`appear` attribute 或是`v-on:appear` hook 都會生成初始渲染過渡。
結合先前的範例，改為一開始就顯示文字過渡：

```html
<div id="app">
  <button @click="show = !show">Toggle</button>
  <transition
    appear
    v-bind:css="false"
    v-on:before-appear="beforeEnter"
    v-on:appear="enter"
    v-on:before-enter="beforeEnter"
    v-on:enter="enter"
    v-on:leave="leave"
  >
    <p v-if="show">Hello</p>
  </transition>
</div>
```

```js
new Vue({
  // ...
  data: {
    show: true // 初始狀態改為 true
  }
  // ...
});
```

## 多元素的過渡

有關多個組件的過渡會在後面章節討論，本節只探討多個原生標籤使用`v-if, v-else`的過渡。

```html
<transition>
  <table v-if="table.length > 0">
    <!-- ... -->
  </table>
  <p v-else>No data.</p>
</transition>
```

> `v-if, v-else`作用在不同標籤時(如：`<table>, <p>`)，可以這樣用，但如果在相同名稱的標籤之間切換時，最好在標籤上設置`key` attribute 讓 Vue 能夠區分它們，否則 Vue 為了效能只會替換相同標籤內部的內容，即便技術上沒有必要。因此，==較好的方式是為`<transition>`組件內的多個切換元素設置`key`==。

```html
<transition>
  <button v-if="isEditing" key="save">Save</button>
  <button v-else key="edit">Edit</button>
</transition>
```

上例也可以在同一元素`<button>`上綁定`v-bind:key="isEditing"`來取代`v-if, v-else`：

```html
<transition>
  <button v-bind:key="isEditing">
    {{isEditing ? 'Save' : 'Edit'}}
  </button>
</transition>
```

相同標籤使用了多個`v-if`的多元素過渡可以改寫為綁定了動態狀態的單元素過渡：

```html
<transition>
  <button v-if="docState == 'saved'" key="saved">Edit</button>
  <button v-if="docState == 'edited'" key="edited">Save</button>
  <button v-if="docState == 'editing'" key="editing">Cancel</button>
</transition>
```

改寫如下：

```html
<transition>
  <button v-bind:key="docState">
    {{buttonText}}
  </button>
</transition>
```

```js
new Vue({
  // ...
  computed: {
    buttonText: function() {
      switch (this.docState) {
        case 'saved':
          return 'Edit';
        case 'edited':
          return 'Save';
        case 'editing':
          return 'Cancel';
      }
    }
  }
});
```

### 過渡模式

```html
<transition enter-active-class="animated fadeInRight" leave-active-class="animated fadeOutLeft">
  <button v-bind:key="isActive" v-on:click="isActive = !isActive">
    {{buttonText}}
  </button>
</transition>
```

```js
...
data: {
  isActive: true
},
computed: {
  buttonText: function(){
    return this.isActive ? 'On' : 'Off'
  }
}
```

==由於`<transition>`的預設行為是進入與離開同時發生==，因此 On 與 Off 按鈕在一個離開過渡時，另一個開始進入過渡，導致這 2 個過渡被同時重繪了。

當這 2 個按鈕採絕對定位時，看起來是正常滑動的，但同時生效的進入與離開的過渡並不能滿足所有需求，所以 Vue 提供了過渡模式：

- `in-out`：新元素先過渡進入，完成後，現有元素再過渡離開。
- `out-in`：現有元素先過渡離開，完成後，新元素再過渡進入。

用`out-in`改寫上面範例：

```html
<transition
  mode="out-in"
  enter-active-class="animated fadeInRight"
  leave-active-class="animated fadeOutLeft"
>
  ...
</transition>
```

## 多組件的過渡

多組件過渡不需要在組件綁定`key`，只要使用**動態組件**即可。

```html
<div id="app">
  <tab-item
    v-for="tab in tabs"
    v-bind:key="tab.name"
    v-bind:name="tab.name"
    v-on:click="currentTab = tab.component"
  >
  </tab-item>
  <transition
    mode="out-in"
    enter-active-class="animated fadeIn"
    leave-active-class="animated fadeOut"
  >
    <!-- 必要時也可結合 keep-alive 緩存動態組件的狀態 -->
    <keep-alive>
      <component v-bind:is="currentTab"></component>
    </keep-alive>
  </transition>
</div>
```

```js
new Vue({
  el: '#app',
  data: {
    currentTab: 'home',
    tabs: [
      { name: 'Home', component: 'home' },
      { name: 'Post', component: 'post' },
      { name: 'Archive', component: 'archive' }
    ]
  },
  components: {
    'tab-item': {
      props: {
        name: String
      },
      template: `
        <button v-on:click="$emit('click')">
         {{name}}
        </button>
      `
    },
    home: {
      template: '<h2>This is Home.</h2>'
    },
    post: {
      template: '<h2>This is Post.</h2>'
    },
    archive: {
      template: '<h2>This is Archive.</h2>'
    }
  }
});
```

## 列表過渡

前面提到的單元素 / 單組件、多元素 / 多組件的過渡，其實都是在處理單一節點的過渡。如果要處理整個列表 ( 比如這個列表是用`v-for`生成的 )，就要使用`<transition-group>`這個組件，它有幾個特點：

- 不同於`<transition-gro>`，它會以一個真實元素呈現，預設是`<span>`，你也可以使用`tag` attribute 更換其它元素。
- 不可使用過渡模式，因為不再相互切換獨有的元素。
- 內部元素**必須提供唯一的`key`**。
- CSS transition class 會應用在內部元素中，而不是`<transition-group>`本身。

### 列表的進入/離開過渡

```html
<div id="app">
  <button v-on:click="add">Add</button>
  <button v-on:click="remove">Remove</button>
  <transition-group tag="ul" name="num">
    <li v-for="item in items" v-bind:key="item" class="num__item">{{item}}</li>
  </transition-group>
</div>
```

```js
new Vue({
  el: '#app',
  data: {
    items: [1, 2, 3, 4, 5, 6, 7, 8, 9],
    nextNum: 10
  },
  methods: {
    randomIndex: function() {
      return Math.floor(Math.random() * this.items.length);
    },
    add: function() {
      this.items.splice(this.randomIndex(), 0, this.nextNum++);
    },
    remove: function() {
      this.items.splice(this.randomIndex(), 1);
    }
  }
});
```

```css
.num-enter,
.num-leave-to {
  opacity: 0;
  transform: translateX(-100px);
}
.num-enter-active,
.num-leave-active {
  transition: all 0.6s;
}
```

### 列表的移動過渡

上面的例子有個問題，當新增和刪除元素時，周圍的元素會瞬間移到新位置，而不是平滑移動。

要解決這個問題，可以使用`<transition-group>`的另一個特殊功能：它不只能在元素進入/離開時加入過渡效果，也可以在其它元素改變定位的過程加入過渡效果，此時要使用`v-move`替改變定位的元素加入 class (`.v-move`)，同樣可以使用`name="xxx"`做為前綴( `.xxx-move`) 或`move-class="myMove"`自定 class name。

上例改寫如下：

```css
.num-enter,
.num-leave-to {
  opacity: 0;
  transform: translateX(-100px);
}
.num-leave-active {
  position: absolute;
}
.num__item {
  transition: all 0.6s;
}
```

如此，列表的一切變動都會有過渡效果。

### 列表的交錯過渡

通過 `:data-` attribute 與 JavaScript 溝通，就能實現列表的交錯過渡 (==具有時間差的過渡==)：

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.0.5/gsap.min.js"></script>
<div id="app">
  <input type="text" v-model="query" placeholder="find someone" />
  <transition-group
    tag="ul"
    v-bind:css="false"
    v-on:before-enter="beforeEnter"
    v-on:enter="enter"
    v-on:leave="leave"
  >
    <li v-for="(user, index) in filteredList" v-bind:key="user.name" v-bind:data-index="index">
      {{user.name}}
    </li>
  </transition-group>
</div>
```

```js
new Vue({
  el: '#app',
  data: {
    list: [
      { name: 'Bruce Lee' },
      { name: 'Jackie Chan' },
      { name: 'Chuck Norris' },
      { name: 'Jet Li' },
      { name: 'Kung Fury' }
    ],
    query: ''
  },
  computed: {
    filteredList: function() {
      const vm = this;
      return this.list.filter(function(item) {
        return item.name.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1;
      });
    }
  },
  methods: {
    beforeEnter: function(el) {
      el.style.opacity = 0;
      el.style.height = 0;
    },
    enter: function(el, done) {
      // 利用 data-index 設定過渡元素的時間差
      gsap.to(el, {
        opacity: 1,
        height: 'auto',
        duration: 0.4,
        delay: parseInt(el.dataset.index) * 0.1,
        onComplete: done
      });
    },
    leave: function(el, done) {
      gsap.to(el, {
        opacity: 0,
        height: 0,
        duration: 0.4,
        delay: parseInt(el.dataset.index) * 0.1,
        onComplete: done
      });
    }
  }
});
```

## 可重複使用的過渡

只要將`<transition>`或`<transition-group>`作為組件的根元素即可。

使用 template 的簡單例子：

```js
Vue.component('my-component', {
  template: `
  <transition
    name="fade"
    mode="out-in"
    v-on:before-enter="beforeEnter"
    v-on:enter="enter"
    v-on:leave="leave">
    <slot></slot>
  </transition>
  `,
  methods: {
    beforeEnter: function(el) {
      // ...
    },
    enter: function(el, done) {
      // ...
    },
    leave: function(el, done) {
      // ...
    }
  }
});
```

**函數式組件 (functional components)** 更適合完成這項工作：

```js
Vue.component('my-component', {
  functional: true,
  render: function(createElement, context) {
    var data = {
      props: {
        name: 'fade',
        mode: 'out-in'
      },
      on: {
        beforeEnter: function(el) {
          // ...
        },
        enter: function(el, done) {
          // ...
        },
        leave: function(el, done) {
          // ...
        }
      }
    };
    return createElement('transition', data, context.children);
  }
});
```

## 動態過渡

在 Vue 中即使是過渡也是資料驅動的，動態過渡最基本的例子是通過`name` attribute 來綁定動態值。

```html
<transition v-bind:name="transitionName">
  ...
</transition>
```

任何 transition attrubite 都可以動態綁定，不只如此，還可以使用 event hooks 來存取上下文的資料，因為 event hooks 都是方法，也就是說，根據狀態的不同，你的 JavaScript 過渡會有不同的表現。

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.0.5/gsap.min.js"></script>
<div id="app">
  Fade In: <input type="range" min="0" v-bind:max="maxFadeInValue" v-model="fadeInValue" />

  Fade Out: <input type="range" min="0" v-bind:max="maxFadeOutValue" v-model="fadeOutValue" />
  <button v-on:click="toggleStop">{{stop ? 'Start animating' : 'Stop'}}</button>
  <transition
    v-bind:css="false"
    v-on:before-enter="beforeEnter"
    v-on:enter="enter"
    v-on:leave="leave"
  >
    <p v-if="show">Hello</p>
  </transition>
</div>
```

```js
new Vue({
  el: '#app',
  data: {
    show: false,
    stop: false,
    maxFadeInValue: 1000,
    fadeInValue: 500,
    maxFadeOutValue: 1000,
    fadeOutValue: 500
  },
  mounted: function() {
    this.show = true;
  },
  methods: {
    toggleStop: function() {
      this.stop = !this.stop;
      this.show = true;
    },
    beforeEnter: function(el) {
      el.style.opacity = 0;
    },
    enter: function(el, done) {
      const vm = this;
      gsap.to(el, {
        opacity: 1,
        duration: vm.fadeInValue / 1000,
        onComplete: function() {
          done();
          if (!vm.stop) {
            vm.show = false;
          }
        }
      });
    },
    leave: function(el, done) {
      const vm = this;
      gsap.to(el, {
        opacity: 0,
        duration: vm.fadeOutValue / 1000,
        onComplete: function() {
          done();
          vm.show = true;
        }
      });
    }
  }
});
```

==創建動態過渡的最終方案是藉由組件的`props`來動態修改之前的過渡。==

# 狀態過渡

---

Vue 的過渡系統除了可使用於元素/組件，還可用於資料本身，例如：

- 數字和運算
- 顏色的顯示
- SVG 節點的位置
- 元素的大小和其他屬性

這些資料的型態為數字或是可轉換為數字型態，有了這些數值，我們可以結合 Vue 的響應式和組件系統，使用第三方程式庫來實現切換元素的過渡狀態。

## 使用監聽器動畫狀態

以下例子，當輸入框的數字更新時，就會觸發動畫改變數值：

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.0.5/gsap.min.js"></script>
<div id="app">
  <input type="number" v-model.number="num" step="20" />
  <p>{{animatedNumber}}</p>
</div>
```

```js
new Vue({
  el: '#app',
  data: {
    num: 0,
    tweenNumber: 0
  },
  computed: {
    animatedNumber: function() {
      return this.tweenNumber.toFixed(0);
    }
  },
  watch: {
    num: function(newValue) {
      gsap.to(this.$data, 0.5, { tweenNumber: newValue });
    }
  }
});
```

對於非數字型態的資料，例如：CSS color 的值，一樣可以處理：

```html
<div id="app">
  <input
    type="text"
    v-model="colorCode"
    v-on:keyup.enter="updateColor"
    placeholder="Enter a color"
  />
  <p style="width:100px;height:100px;" :style="{backgroundColor: tweenColor}"></p>
</div>
```

```js
new Vue({
  el: '#app',
  data: {
    colorCode: 'red',
    tweenColor: 'red'
  },
  methods: {
    updateColor: function() {
      gsap.to(this.$data, 1, { tweenColor: this.colorCode });
    }
  }
});
```

## 把過渡放到組件裡

管理太多的狀態過渡會很快的增加 Vue 實體或是組件的複雜性，此時應該建立子組件處理這些相同性質的狀態過渡。

將先前的數字動畫改寫如下：

```html
<div id="app">
  <input type="number" v-model.number="num1" step="20" />
  +
  <input type="number" v-model.number="num2" step="20" />
  = {{result}}
  <div>
    <animated-integer v-bind:value="num1"></animated-integer>
    +
    <animated-integer v-bind:value="num2"></animated-integer>
    =
    <animated-integer v-bind:value="result"></animated-integer>
  </div>
</div>
```

```js
// 這種複雜的補間動畫邏輯可以被重複使用在任何整數
// 組件化提供了一個更加清晰的界面，便於理解複雜的動態過渡
Vue.component('animated-integer', {
  template: '<span>{{animatedNumber}}</span>',
  props: {
    value: {
      type: Number,
      require: true
    }
  },
  data: function() {
    return {
      tweenNum: this.value
    };
  },
  computed: {
    animatedNumber: function() {
      return this.tweenNum.toFixed(0);
    }
  },
  watch: {
    value: function(newValue) {
      gsap.to(this.$data, 1, { tweenNum: newValue });
    }
  }
});

// 所有複雜的動態過渡都從 Vue 實體移除了
new Vue({
  el: '#app',
  data: {
    num1: 0,
    num2: 0
  },
  computed: {
    result: function() {
      return this.num1 + this.num2;
    }
  }
});
```
