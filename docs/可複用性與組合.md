[TOC]

# 混入 Mixins

---

## 基礎

Mixin 提供了一種非常靈活的方式，來分發 Vue 組件中的可複用功能。一個 mixin object 可以包含任何組件選項，當組件使用 mixin object 時，所有 mixin object 的選項都將被"混合"進入該組件的選項。

例子：

```js
// 定義一個 mixin object
const myMixin = {
  created: function() {
    this.hello();
  },
  methods: {
    hello: function() {
      console.log('Hello from mixins');
    }
  }
};

// 定義一個使用 mixin object 的組件
const Component = Vue.extend({
  mixins: [myMixin]
});

const com = new Component(); // => Hello from mixins
```

## 選項合併

當組件與 mixin object 含有同名選項時，這些選項將以適當的方式進行"合併"。

- `data`：會在內部進行遞迴合併，並在==發生衝突時以組件資料優先==。

```js
const mixin = {
  data: function() {
    return {
      message: 'hello',
      foo: 'abc'
    };
  }
};

new Vue({
  mixins: [mixin],
  data: {
    message: 'goodbye',
    bar: 'xyz'
  },
  created: function() {
    console.log(this.$data);
    // => {bar: "xyz", foo: "abc", message: "goodbye"}
  }
});
```

- `Hook functions`
  同名的鉤子函數會被合併為一個陣列，都會被呼叫，而且 mixin hooks 會比組件本身的鉤子更先被呼叫。

```js
const mixin = {
  created: function() {
    console.log('mixin hook called');
  }
};
new Vue({
  mixins: [mixin],
  created: function() {
    console.log('instance hook called');
  }
});
// => mixin hook called
// => component hook called
```

- `object-based options` (值為物件的選項)，如：`methods, components, directives, computed`，將被合併為同一個物件，==當 key name 衝突時，以組件的 key value 優先==。

```js
const mixin = {
  methods: {
    foo: function() {
      console.log('foo');
    },
    conflicting: function() {
      console.log('conflicting from mixin');
    }
  }
};
const vm = new Vue({
  mixins: [mixin],
  methods: {
    bar: function() {
      console.log('bar');
    },
    conflicting: function() {
      console.log('conflicting from instance');
    }
  }
});
vm.foo(); // =>'foo'
vm.bar(); // =>'bar'
vm.conflicting(); // =>'conflicting from instance'
```

注意，==`Vue.extend()`也使用同樣策略進行合併==。

## 全域混入

```js
// 為自定義選項 `myOption` 注入一個處理器
Vue.mixin({
  created: function() {
    const myOption = this.$options.myOption;
    if (myOption) {
      console.log(myOption);
    }
  }
});

new Vue({
  myOption: 'hello'
});
// => "hello"
```

==請謹慎使用全域混入，因為它會影響每個單獨創建的 Vue 實體(包括第三方組件)。在大多數情況下，應該只使用於自定義選項，如上例一樣。推薦將它作為插件發布，以避免混入被重複應用。==

## 自定義選項合併策略

自定義選項會使用預設策略：如有衝突，新值將會覆蓋現有值。如果想讓自定義選項以自定義邏輯合併，可以在`Vue.config.optionMergeStrategies`添加一個函數：

```js
Vue.config.optionMergeStrategies.maxValue = function(toVal, fromVal) {
  if (!toVal) return fromVal;
  if (!fromVal) return toVal;
  return toVal > fromVal ? toVal : fromVal;
};
Vue.mixin({
  maxValue: 100
});

const vm = new Vue({
  maxValue: 99
});
console.log(vm.$options.maxValue);
// 採用預設的合併策略 => 99
// 採用自定義合併策略 => 100
```

對於值為物件的選項(object-based options)，可以使用與`methods`相同的合併策略：

```js
const strategies = Vue.config.optionMergeStrategies;
strategies.myOption = strategies.methods;
```

可以在 Vuex 1.x 的混入策略裡找到更高級的例子：

```js
const merge = Vue.config.optionMergeStrategies.computed;
Vue.config.optionMergeStrategies.vuex = function(toVal, fromVal) {
  if (!toVal) return fromVal;
  if (!fromVal) return toVal;
  return {
    getters: merge(toVal.getters, fromVal.getters),
    state: merge(toVal.state, fromVal.state),
    actions: merge(toVal.actions, fromVal.actions)
  };
};
```

# 自定義指令

---

## 簡介

除了核心功能預設內建的指令(`v-model, v-show`)，Vue 也允許註冊自定義指令。在 Vue 2.0 中，程式碼複用與抽象的主要形式是組件。然而在有些情況下，你仍然需要對普通的 DOM 元素進行底層操作，此時就會用到自定義指令，例如，自動聚焦在指定的輸入框( `autofocus`不支援 iOS Safari )，可以用自定義指令達成：

```js
// 註冊一個全域自定義指令
Vue.directive('focus', {
  // 當綁定的元素插入到 DOM 時...
  inserted: function(el) {
    // 聚焦元素
    el.focus();
  }
});

// 註冊一個區域自定義指令
new Vue({
  el: '#app',
  directives: {
    focus: {
      inserted: function(el) {
        el.focus();
      }
    }
  }
});
```

然後就可以在 template 中的任何元素使用`v-focus` attribute：

```html
<input v-focus />
```

## 指令鉤子函數 (Directive Hook Functions)

一個指令定義物件可以提供以下 5 個鉤子函數(均為非必填)：
Hook Function | 說明
:---:|:---
`bind`|指令第一次綁定到元素時調用。(只調用一次，適合初始化設置。)
`unbind`|指令與元素解除綁定時調用。(只調用一次)
`inserted`|被綁定的元素插入父節點時調用。(只保證父節點存在，但不一定已被插入文件中。)
`update`|所在組件的 VNode 更新時調用，**但可能發生在它的子 VNode 更新之前**。指令的值可能發生了改變，也可能沒有。你可以藉由比對更新前後的值來忽略不必要的模板更新。(見底下的 Hook Arguments，更多 VNode 的細節會在 Render Functions 介紹。 )
`componentUpdated`|指令所在组件的 VNode 及其子 VNode 全部更新後調用。

## 指令鉤子參數 (Directive Hook Arguments)

指令鉤子函數會被傳入以下 4 個參數：
Hook Argument | 說明
:---: | :---
`el`| 指令所綁定的 DOM 元素
`binding` | 一個物件，包含以下 6 個屬性： <ul><li>`name`： 指令名稱，不包含`v-`前綴 </li><li>`arg`：傳給指令的參數，非必填，例如：`v-my-directive:foo`，參數為`foo`</li><li>`modifiers`：一個包含修飾符的物件，例如：`v-my-directive.foo.bar`，修飾符物件為`{foo: true, bar: true}`。</li><li>`value`：指令的綁定值，例如：`v-my-directive="1 + 1"`，綁定值為`2`</li><li>`oldValue`：指令綁定的前一個值，只能用在`update, componentUpdated`這 2 個鉤子函數中，無論值是否改變都可用。 </li><li>`expression`：以字串形式綁定的表達式，例如：`v-my-directive="1 + 1"`，表達式為`"1 + 1"`</li></ul>
`vnode` | Vue 編譯生成的虛擬節點，詳情見[VNode API](https://cn.vuejs.org/v2/api/#VNode-%E6%8E%A5%E5%8F%A3) |
`oldVnode` | 上一個虛擬節點，只能用在`update, componentUpdated`這 2 個鉤子函數中。

==除了`el`之外，其它參數應該保持**唯讀性**，切勿進行修改；如果需要在鉤子之間共享資料，可以透過元素的`dataset`來進行。==

範例：

```html
<div id="app" v-demo:foo.a.b="message"></div>
```

```js
Vue.directive('demo', {
  bind: function(el, binding, vnode) {
    const s = JSON.stringify;
    el.innerHTML = `
    <ul>
      <li>name: ${s(binding.name)}</li>
      <li>argument: ${s(binding.arg)}</li>
      <li>modifiers: ${s(binding.modifiers)}</li>
      <li>value: ${s(binding.value)}</li>
      <li>expression: ${s(binding.expression)}</li>
      <li>vnode keys: ${Object.keys(vnode).join(', ')}
    </ul>
    `;
  }
});

new Vue({
  el: '#app',
  data: {
    message: 'hello'
  }
});
```

結果如下：

- name: "demo"
- argument: "foo"
- modifiers: {"a":true,"b":true}
- value: "hello 123"
- expression: "message"
- vnode keys: tag, data, children, text, elm, ns, context, fnContext, fnOptions, fnScopeId, key, componentOptions, componentInstance, parent, raw, isStatic, isRootInsert, isComment, isCloned, isOnce, asyncFactory, asyncMeta, isAsyncPlaceholder

### 動態指令參數 (Dynamic Directive Arguments)

在`v-mydirective:[argument]="value"`中，`argument`可以根據組件實體資料進行更新，例如：你想要創建一個指令，用來將元素固定在頁面上，我們可以建立一個能夠更新垂直位置的自定義指令：

```html
<div id="app">
  <p>Scroll down the page</p>
  <p v-pin="200">Stick me 200px from the top of the page</p>
</div>
```

```js
Vue.directive('pin', {
  bind: function(el, binding) {
    el.style.position = 'fixed';
    el.style.top = binding.value + 'px';
  }
});
new Vue({
  el: '#app'
});
```

或者以更直覺的方式改寫如下：

```html
<div id="app">
  <p>Scroll down the page</p>
  <p v-pin:top="200">Stick me 200px from the top of the page</p>
</div>
```

```js
Vue.directive('pin', {
  bind: function(el, binding) {
    const direction = binding.arg;
    const value = binding.value;
    el.style.position = 'fixed';
    el.style[direction] = value + 'px';
  }
});
new Vue({
  el: '#app'
});
```

這會將元素固定在距離頁面頂部 200px 的位置，如果想要靈活變更位置，可以使用**動態參數**改寫如下：

```html
<div id="app">
  <p>Scroll down the page</p>
  <p v-pin:[direction]="value">Stick me {{value}}px from the top of the page</p>
</div>
```

```js
Vue.directive('pin', {
  bind: function(el, binding) {
    const direction = binding.arg;
    const value = binding.value;
    el.style.position = 'fixed';
    el.style[direction] = value + 'px';
  }
});

new Vue({
  el: '#app',
  data: {
    direction: 'top',
    value: 200
  }
});
```

## 函數縮寫

很多時候，你可能只想在`bind`與`update`時觸發相同行為，而不關心其他鉤子，可以這樣寫：

```js
Vue.directive('color-swatch', function(el, binding) {
  el.style.backgroundColor = binding.value;
});
```

## Object Literals

指令函數能夠接收所有合法的 JavaScript Expression，因此，如果指令需要多個值，可以傳入一個物件：

```html
<div v-demo="{color: 'red', text: 'hello!'}"></div>
```

```js
Vue.directive('demo', {
  bind: function(el, binding) {
    console.log(binding.value.color); // => "red"
    console.log(binding.value.text); // => "hello!"
  }
});
```

# Render Functions & JSX

---

## 基礎

Vue 推薦在大多數情況下使用 templates 來創建你的 HTML，但在某些情況下，你真的需要 JavaScript 的完全編程能力，此時可以用 Render Functions ，它比 templates 更接近編譯器。

假設我們要建立一些帶錨點的標題(h1-h6)，可以使用`render`函數：

```html
<!-- 建立帶有錨點的 h1 標題 -->
<h1>
  <a name="hello-world">
    Hello world!
  </a>
</h1>
```

組件內容：

```html
<anchored-heading level="1" name="hello">Hello world!</anchored-heading>
```

```js
Vue.component('anchored-heading', {
  props: {
    level: {
      type: Number,
      required: true
    },
    name: {
      type: String,
      required: true
    }
  },
  template: `
    <h1 v-if="level === 1">
      <a name="name">
        <slot></slot>
      </a>
    </h1>
    ...    
    <h6 v-else-if="level === 6">
      <a name="name">
        <slot></slot>
      </a>
    </h6>
  `
});
```

這樣的 template 太冗長了，而且重複了許多`<slot></slot>`，這種情形就適合使用`render`函數來重寫：

```js
Vue.component('anchored-heading', {
  props: {
    level: {
      type: Number,
      required: true
    },
    name: {
      type: String,
      required: true
    }
  },
  render: function(createElement) {
    /* template 結構
      <h1~6>
        <a :name="name">
          <slot></slot>
        </a>
      </h1~6>
    */
    return createElement(
      'h' + this.level, // tag name
      [
        createElement(
          'a',
          {
            attrs: {
              name: this.name
            }
          },
          this.$slots.default
        )
      ] // 子節點
    );
  }
});
```

這樣的程式碼精簡很多，但需要非常熟悉 Vue 的實體屬性，在這個例子中，你需要知道，向組件傳遞不帶`v-slot`的子節點時，比如`anchored-heading`中的`Hello world!`，這些子節點被儲存在組件實體中的`$slots.default`。

## 節點、樹、Virtual DOM

在深入了解渲染函數之前，先認識瀏覽器如何解析 HTML (DOM tree)。

```html
<div>
  <h1>My title</h1>
  Some text content
  <!-- TODO: Add tagline -->
</div>
```

![DOM tree](https://cn.vuejs.org/images/dom-tree.png)

### Virtual DOM

Vue 藉由建立一個 virtual DOM 來追蹤自己要如何改變 reel DOM。

```js
return createElement('h1', this.blogTitle);
```

createElement 返回的並不是一個真實的 DOM 元素，而是節點的描述訊息，告訴 Vue 應該在頁面上渲染什麼樣的節點及子節點，這樣的節點描述稱為"virtuel node"，簡稱**VNode**，==virtual DOM 指的就是由 Vue 組件樹所建立起來的整個 VNode tree。==

## createElement 參數

(`String | Object | Function` , `Object`(optional) , `String | Array`)

### 深入 Data Object

```js
{
  // 與 `v-bind:class` API 相同
  // 可接受 string, object, or array of strings and objects
  class: {
    foo: true,
    bar: false
  },
  // 與 `v-bind:style` API 相同
  // 可接受 string, object, or array of objects
  style: {
    fontSize: '18px',
    color: 'red'
  },
  // 普通的 HTML attribute，如：id、title、align
  attrs: {
    id: 'foo'
  },
  // 組件 props
  props: {
    myProp: 'bar'
  },
  // DOM Property，如：value, innerHTML, innerText
  domProps: {
    innerHTML: 'baz' // innerHTML 會覆蓋 v-html 指令
  },
  // 用於組件內部的事件監聽，
  // 但不支援 `v-on:keyup.enter` 這樣的修飾符,
  // 需要在處理函數中手動檢查 keyCode。
  on: {
    click: this.clickHandler
  },
  // 相當於 v-on:click.native，只能用於組件，監聽組件內部的原生事件，
  // 而不是組件內部使用 `vm.$emit` 觸發的 events。
  nativeOn: {
    click: this.nactiveClickHandler
  },
  // 自定義指令。注意，你無法為 `oldValue` 賦值，
  // 因為 Vue 已經自動為你進行同步了。
  directives: [
    {
      name: 'my-custom-directive',
      arg: 'foo',
      modifires: {
        bar: true
      },
      expression: '1 + 1',
      value: '2'
    }
  ],
  // 作用域插槽的格式為
  // { name: props => VNode | Array<VNode> }
  scopedSlots: {
    default: props => createElement('span', props.text)
  },
  // 如果該組件是其它組件的子組件，需要為插槽命名
  slot: 'name-of-slot',
  // Other special top-level properties
  key: 'myKey',
  ref: 'myRef',
  // 如果你在渲染函數中為多個元素上套用相同的 ref 名稱，
  // 那麼 `$refs.myRef` 會變成一個 array。
  refInFor: true
}
```

### 約束條件

==**VNode 必須唯一**==
組件樹的所有 VNodes 必須是唯一的，這代表下面的渲染函數是不合法的：

```js
render: function(createElement){
  const myVNode = createElement('p','hello')
  return createElement('div',[
    // 重複的 VNode
    myVNode, myVNode
  ])
}
```

如果你真的需要重複很多次元素/組件，可以使用工廠函數來實現：

```js
render: function(createElement){
  return createElement('div',
    Array.apply(null, {length: 20}).map(function(){
      return createElement('p','hello')
    })
  )
}
```

## 使用 JavaScript 代替模板功能

### `v-if` & `v-for`

```html
<ul v-if="items.length">
  <li v-for="item in items">{{ item.name }}</li>
</ul>
<p v-else>No items found.</p>
```

這些都可以在渲染函數使用 JavaScript 的 `if/else`和`map`來重寫：

```js
render: function(createElement){
  if(this.items.length){
    return createElement('ul',
      this.items.map(function(item){
        return createElement('li', item.name)
      })
    )
  } else {
    return createElement('p','No items found.')
  }
}
```

### `v-model`

Render Function 並沒有與`v-model`直接對應，你必須自行實作邏輯：

```js
props: ['keyword'],
render: function(createElement){
  const vm = this
  return createElement('input',{
    attrs: {
      placeholder: 'enter a word'
    },
    domProps: {
      value: vm.keyword
    },
    on: {
      input: function(event){
        vm.$emit('input',event.target.value)
      }
    }
  })
}
```

這是深入底層的代價，但與`v-model`相比，可以讓你更好控制互動細節。

### Event & Key Modifiers

對於`.passive`、`.capture`和`.once`這些事件修飾符，Vue 提供了對應的前綴可用於 render function 的`on`：
修飾符 | 前綴
:---:|:---
`.passive` | `&`
`.capture` | `!`
`.once` | `~`
`.capture.once`或`.once.capture` | `~!`

例如：

```js
on: {
  '!click': this.doThisInCapturingMode,
  '~keyup': this.doThisOnce,
  '~!mouseover': this.doThisOnceInCapturingMode
}
```

對於其它事件與按鍵修飾符，前綴都是不必要的，因為你可以在事件處理函數中使用事件方法：
事件/按鍵修飾符 | 處理函數中的等價操作
:---|:---
`.stop` | `event.stopPropagation()`
`.prevent` | `event.preventDefault()`
`.self` | `if (event.target !== event.currentTarget) return`
`.enter`, `.13` | `if (event.keyCode !== 13)` 對於其它按鍵代碼可使用 [keyCode 查詢](http://keycode.info/)
`.ctrl`, `.alt`,`.shift`,`.meta` | `if (!event.ctrlKey) return` (可將`ctrlKey`分別修改為`altKey`, `shiftKey`, `metaKey`)

使用所有修飾符的例子：

```js
on: {
  '~keyup': function (event) {
    // 如果觸發 event 的元素不是事件绑定的元素
    // 則返回，相當於 `.self`
    if (event.target !== event.currentTarget) return

    // 如果按下去的不是 enter 键或者
    // 没有同时按下 shift 键
    // 則返回，相當於 `.shift.enter`
    if (!event.shiftKey || event.keyCode !== 13) return

    // 阻止 event 冒泡，相當於 `.stop`
    event.stopPropagation();

    // 阻止該元素預設的 keyup handler，相當於 `.prevent`
    event.preventDefault();
    // ...
  }
}
```

### Slots

你可以藉由`this.$slots`存取靜態插槽的內容，每個插槽都是一個 VNode array。

```js
// <div><slot></slot></div>
render: function(createElement){
  return createElement('div', this.$slots.default)
}
```

也可以使用`this.$scopedSlots`存取作用域插槽，每個作用域插槽都是一個返回若干 VNode 的函數：

```js
props: ['message'],
render: function(createElement){
  // <div><slot :text="message"></slot></div>
  return createElement('div', [
    this.$scopedSlots.default({
      text: this.message
    })
  ])
}
```

==如果你在使用 Render Function，無論所使用的插槽是否帶有作用域，Vue 都建議始終使用`$scopedSlots`存取它們，這不僅讓未來添加作用域變得簡單，也可以讓你輕鬆升級到所有插槽都是函數的 Vue 3。==

如果要使用 Render Function 向子組件傳遞作用域插槽，可以利用 VNode 的`scopedSlots`：

```js
render: function (createElement) {
  return createElement('div', [
    createElement('child', {
      // pass `scopedSlots` in the data object
      // 格式為 { name: props => VNode | Array<VNode> }
      scopedSlots: {
        default: function (props) {
          return createElement('span', props.text)
        }
      }
    })
  ])
}
```

## JSX

如果你寫了很多的`render`函數，可能會覺得下面的程式碼寫起來很痛苦：

```js
render: function(createElement){
  return createElement('anchored-heading',{
    props: {
      level: 1
    }, [
      createElement('span','Hello'),
      ' world!'
    ]
  })
}
```

特別是對應的 Template 如此簡單的情況下：

```html
<anchored-heading :level="1"> <span>Hello</span> world! </anchored-heading>
```

這就是為何會有一個 [Babel plugin](https://github.com/vuejs/jsx)，用於在 Vue 中使用 JSX 語法，讓我們回到更接近於 Template 的語法上。

```js
import AnchoredHeading from './AnchoredHeading.vue';

new Vue({
  el: '#demo',
  render: function(h) {
    return (
      <AnchoredHeading level={1}>
        <span>Hello</span> world!
      </AnchoredHeading>
    );
  }
});
```

> 將`h`作為`createElement`的別名是 Vue 生態系統的一個通用慣例，也是 JSX 所要求的。從 Vue 的 Babel plugin [v3.4.0](https://github.com/vuejs/babel-plugin-transform-vue-jsx#h-auto-injection)開始，我們會在以 ES2015 的語法宣告含有 JSX 的任何方法和 getter (不是函數或箭頭函數)中自動注入`const h = this.$createElement`，這樣你就可以去掉`(h)`參數了。對於更早版本的 plugin，如果`h`在當前作用域中不可用，應該會拋錯。

## 函數式組件 (Functional Component)

先前建立的`<anchored-heading>`組件比較簡單，它沒有管理任何狀態，沒有監聽任何傳遞給它的狀態，也沒有任何生命周期方法。實際上，它只是一個接收 prop 的函數。

```html
<anchored-heading level="1" name="hello">Hello world!</anchored-heading>
```

```js
Vue.component('anchored-heading', {
  props: {
    level: {
      type: Number,
      required: true
    },
    name: {
      type: String,
      required: true
    }
  },
  render: function(createElement) {
    /* template 結構
      <h1~6>
        <a :name="name">
          <slot></slot>
        </a>
      </h1~6>
    */
    return createElement(
      'h' + this.level, // tag name
      [
        createElement(
          'a',
          {
            attrs: {
              name: this.name
            }
          },
          this.$slots.default
        )
      ] // 子節點
    );
  }
});
```

在這樣的場景下，我們可以將組件標記為`functional`，這意味著它沒有狀態(沒有響應式資料)，也沒有實體(沒有`this`上下文)。

一個函數式組件就像這樣：

```js
Vue.component('my-component', {
  functional: true,
  // Props are optional
  props: {
    // ...
  },
  // 為了彌補缺少的實體
  // 提供第二個參數作為上下文
  render: function(createElement, context) {
    // ...
  }
});
```

> **注意：在 2.3.0 之前的版本中，如果一個函数式组件想要接收 prop，則`props`選項是必要的。在 2.3.0 以上的版本中，你可以省略`props`選項，所有组件上的 attribute 都會被自動隱式解析為`prop`。
> 當使用函數式组件時，該引用將會是 HTMLElement，因为他們沒有狀態也沒有實體。**

在 2.5.0 以上的版本中，如果你使用了單文件組件，那麼基於模板(template-based)的函數式組件可以這樣宣告：

```html
<template functional> </template>
```

函數式組件所需要的一切都是透過`context`參數傳遞，它是一個物件，包含：

- `props`：提供所有 prop 的物件。
- `children`：VNode 子節點的陣列。
- `slots`：一個函數，回傳包含所有插槽的物件。
- `scopedSlots`：(2.6.0+)一個暴露傳入的作用域插槽的物件。也以函數形式暴露普通插槽。
- `data`：傳遞給組件的整個 Data Object，作為`createElement`的第二個參數傳入組件。
- `parent`：對父組件的引用
- `listeners`：(2.3.0+)一個包含了所有父組件為當前組件註冊的 event listeners 的物件，這是`data.on`的別名。
- `injections`：(2.3.0+)如果使用了`inject`選項，則該物件包含了應當被注入的屬性。

原先的`<anchored-heading>`組件經過下列變動，可以改寫成函數式組件：

- 添加`functional: true`
- `render` 函數增加第二個參數`context`
- `this.level`改為`context.props.level`
- `this.name`改為`context.props.name`
- `this.$slots.default`改為`context.children`

```js
Vue.component('anchored-heading', {
  props: {
    level: {
      type: Number,
      required: true
    },
    name: {
      type: String,
      required: true
    }
  },
  functional: true,
  // 增加第二個參數 context
  render: function(createElement, context) {
    /* template 結構
      <h1~6>
        <a :name="name">
          <slot></slot>
        </a>
      </h1~6>
    */

    // this.level 改為 context.props.level
    return createElement('h' + context.props.level, [
      createElement(
        'a',
        {
          attrs: {
            // this.name 改為 context.props.name
            name: context.props.name
          }
        },
        // this.$slots.default 改為 context.children
        context.children
      )
    ]);
  }
});
```

因為函數式組件只是函數，所以渲染開銷也低了很多。

函數式組件在做為包裝組件時也非常有用，例如，當你需要做這些時：

- 程式化的在多個組件中選擇一個來渲染。
- 在將`children, props, data`傳遞給子組件之前操作它們。

下面是一個`smart-list`組件的例子，它能根據傳入 prop 的值來代為渲染更具體的組件：

```js
var EmptyList = { ... }
var TableList = { ... }
var OrderedList = { ... }
var UnorderedList = { ... }

Vue.component('smart-list', {
  functional: true,
  props: {
    items: {
      type: Array,
      required: true
    },
    isOrdered: Boolean
  },
  render: function(createElement, context){
    function appropriateListComponent(){
      const items = context.props.items

      if(items.length === 0) return EmptyList
      if(typeof items[0] === 'object') return TableList
      if(context.props.isOrdered) return OrderedList

      return UnorderedList
    }

    return createElement(
      appropriateListComponent(),
      context.data,
      context.children
    )
  }
})
```

### 向子元素或子組件傳遞 attribute 和 events

在普通組件中，沒有被定義為 prop 的 attribute，會被添加到組件的根元素上，任何現有的同名 attribute 將會被取代或智慧合併。但是函數式組件要求你明確定義該行為：

```js
Vue.component('my-functional-button', {
  functional: true,
  render: function(createElement, context) {
    // 透明化的傳遞所有 attributes、event listeners、子節點...
    return createElement('button', context.data, context.children);
  }
});
```

向`createElement`傳入`context.data`作為第二個參數時，我們就已經把`my-functional-button`上面所有的 attribute、event listeners 都傳遞下去了，事實上這是非常透明的，那些 events 甚至不要求`.native`修飾符。

如果你使用 template-based 函數式組件，需要手動添加 attributes 和 listeners。因為我們可以存取其獨立的上下文內容，所以可以使用`data.attrs`傳遞任何 HTML attribute，也可以使用`listeners`(`data.on`的別名)傳遞任何 event listeners。

```html
<template functional>
  <button v-bind="data.attrs" v-on="listeners">
    <slot></slot>
  </button>
</template>
```

### `slots()` vs `children`

在函數式組件中，雖然`slots().default`和`children`很類似，但如果組件內不只有一個`<slot>` (default)時，你會同時需要`slots().default`和`children`：

```html
<my-functional-component>
  <p v-slot:foo>first</p>
  <p>second</p>
</my-functional-component>
```

對於上面的組件，`children`會給你二個段落標籤，但`slots().default`只會傳遞第二個匿名段落標籤，`slots().foo`會傳遞第一個具名段落標籤。同時擁有`children`和`slots()`，你可以決定讓組件處理哪個插槽，或是直接傳遞`children`，移交給其他組件去處理。

# 插件

---

插件通常用來為 Vue 添加全域功能，它的功能範圍沒有嚴格的限制，一般有下面幾種：

1. 增加全域方法或屬性，如：[vue-custom-element](https://github.com/karol-f/vue-custom-element)
1. 增加全域資源：directives / filters / transitions 等等，如：[vue-touch](https://github.com/vuejs/vue-touch)
1. 藉由 global mixin 來增加一些組件選項，如：[vue-router](https://github.com/vuejs/vue-router)
1. 在`Vue.prototype`上增加 Vue 的實體方法。
1. 一個提供自身 API 的 Library，同時提供上面提到的一個或多個功能，如：[vue-router](https://github.com/vuejs/vue-router)

## 使用插件

必須在呼叫`new Vue()`之前以全域方法`Vue.use()`才能使用插件：

```js
// calls `MyPlugin.install(Vue)`
Vue.use(MyPlugin);

new Vue({
  //... options
});
```

也可以傳入一些選項：

```js
Vue.use(MyPlugin, { someOption: true });
```

`Vue.use`會自動阻止多次註冊相同插件，屆時即使多次呼叫也只會註冊一次該插件。

Vue.js 官方所提供的插件 (例如`vue-router`) 在檢測到`Vue`這個全域變數時就會自動呼叫`Vue.use()`，但是在 CommonJS 的開發環境中，你仍須明確呼叫`Vue.use()`：

```js
// 用 Browserify 或 webpack 提供的 CommonJS 開發時
const Vue = require('Vue');
const VueRouter = require('vue-router');

// 明確呼叫
Vue.use(VueRouter);
```

[awesome-vue](https://github.com/vuejs/awesome-vue#components--libraries) 收集了大量的 plugins and libraries.

## 開發插件

Vue.js 插件應該暴露一個`install`方法，這個方法的第一個參數是 Vue 建構子，第二個參數是選項物件(optional)：

```js
MyPlugin.install(Vue, options){
  // 1. 增加全域方法或屬性
  Vue.myGlobalMethod = function(){}

  // 2. 增加全域資源
  Vue.directive('my-directive', {
    bind: function(el, binding, value, oldValue){}
  }

  // 3. 藉由 global mixin 來增加一些組件選項
  Vue.mixin({
    created: function(){}
  })

  // 4. 在Vue.prototype上增加 Vue 的實體方法
  Vue.prototype.$myMethod = function(methodOptions){}
}
```

# 過濾器

---

Vue 允許你自訂過濾器，用於一些常見的文字格式化。過濾器可以用在二個地方：**雙大括號插值和`v-bind`表達式**，而且應該添加在 JavaScript Expression 的尾部，以`|`表示：

```html
<!-- 在雙大括號中 -->
{{ message | capitalize }}

<!-- 在 `v-bind` 中 -->
<div v-bind:id="rawId | formatId"></div>
```

定義全域 / 區域過濾器：

```js
// 區域過濾器 (在組件內部或 Vue 實體內定義)
Vue.component('my-component', {
  // ...
  filters: {
    // 過濾器函數會把表達式的值作為第一個參數
    capitalize: function(value) {
      if (!value) return '';
      value = value.toString();
      return value.charAt(0).toUpperCase() + value.slice(1);
    }
  }
});
```

```js
// 全域過濾器 (在建立 Vue 實體之前定義)
Vue.filter('capitalize', function(value) {
  if (!value) return '';
  value = value.toString();
  return value.charAt(0).toUpperCase() + value.slice(1);
});

new Vue({
  // ...
});
```

當全域與區域過濾器命名相同時，會採用區域過濾器。

過濾器可以串連：

```html
<div>{{ message | filterA | filterB }}</div>
```

在這個例子中，`filterA`與`filterB`都定義為接收單一參數的過濾器函數，`message`的值會被傳送到`filterA`，再將`filterA`的結果傳送給`filterB`。

過濾器既然是 JavaScript 函數，當然可以接收多個參數：

```html
<div>{{ message | filterA('arg1', arg2) }}</div>
```

在這個例子中，`filterA`被定義為接收 3 個參數的過濾器函數：

- 第 1 個參數： `message`的值
- 第 2 個參數： 純文字`arg1`
- 第 3 個參數： `arg2`表達式的值
