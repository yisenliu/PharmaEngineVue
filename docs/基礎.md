[TOC]

# Template Syntax

---

## Directive(指令)

### `v-bind`

`v-bind:attribute/property=”data”`，縮寫(`:attribute/property=”data”`)，用於綁定 html tag 的屬性(attribute) 或組件的 props(property)

```html
<img v-bind:alt="message" />
```

```js
<my-component v-bind:message="myProp"></my-component>
```

### `v-if`

條件判斷該 dom 元素是否存在，當 seen = true，`<p>...</p>`會存在於 DOM Tree，反之則不存在。

```html
<p v-if="seen">Now you see me</p>
```

### `v-else`, `v-else-if`

與 `v-if` 搭配，緊跟在 `v-if` 或 `v-else-if` 後面，若同時出現則採 `v-if`, `v-else-if`, `v-else` 順序。

### `v-show`

用法與 `v-if` 類似，但 DOM 會一直存在於頁面，只透過 `style="display:block | none"` 決定是否顯示。

### `v-for`

for 迴圈

```html
<li v-for="todo in list">{{todo.name}}</li>
```

### `v-on:enent`

縮寫(`@event`)，為 DOM 元素綁定特定事件

```html
<button v-on:click="myFunc"></button>
```

```js
methods:{
  myFunc: function(){}
}
```

### `v-model`

雙向綁定表單元件( `<input>, <select>, <textarea>` )與其他元件

```html
<p>{{ message }}</p>
<input v-model="message" />
```

### `v-once`

DOM 元素內的值不會隨 Vue instance 的資料改變而更新

```html
<span v-once>{{ msg }}</span>
```

### `v-html`

Vue 的資料可使用 html tag，但只可用於受信任的內容，絕不可用於使用者自行輸入的內容上，會有安全性隱憂( [XSS vulnerabilities](https://en.wikipedia.org/wiki/Cross-site_scripting) )。

```html
<div v-html="msg"></div>
```

> 若使用`<div>{{ msg }}</div>`，則會將資料內的 html tag 視為純文字輸出

### `Vue.component`

```js
Vue.component('todo-item', {
  props: ['todo'], // 用於接收外部資料
  template: '<li>{{ todo.name }}</li>'
});
```

```html
<ol>
  <!-- 每個component必須有唯一key值 -->
  <todo-item v-for="item in list" v-bind:todo="item" v-bind:key="item.id"></todo-item>
</ol>
```

### `Object.freeze()`

無法追蹤資料的改變而即時反應在 DOM 元素。

```js
const group = {
  people1: 'Peter',
  people2: 'Nick'
};
Object.freeze(group);
const vm = new Vue({
  el: '#app',
  data: group
});
group.people1 = 'Jason'; // 雖然資料有異動，但 DOM 元素的內容卻不會改變
```

### `vm.$el`, `vm.$data`...

Vue instance 透過這種方式可使用該 instance properties and methods. (prefixed with `$`)

```js
// 承上例
vm.$data == group; // true
vm.$el == document.querySelector('#app'); // true
vm.$watch('people1', function( newValue, oldValue ){...}); // $watch is an instance method
```

### Vue 生命週期

分為 4 大類 8 個週期：

1. Create (`beforeCreate`, `created`)
1. Mount (`beforeMount`, `mounted`)
1. Update (`beforeUpdate`, `updated`)
1. Destroy (`beforeDestroy`, `destroyed`)

![Vue 生命週期](https://vuejs.org/images/lifecycle.png)

```js
const vm = new Vue({
el: '#app',
  data: {a: 1},
  created: function(){
    console.log(this.a) // this 指向 vm
    // 絕不可使用arrow function，因為此刻的arrow function沒有this，例如：
    // created: ()=> console.log(this.a), 或是
    // vm.$watch('a', newValue => this.myMethod())
});
```

### Using JavaScript Expressions

Vue 不只能綁定簡單的 property key，也能透過 JavaScript Expression 作資料綁定(只允許”單行表達式 one single expression”)

```html
<!-- 簡單綁定 -->
<div>{{ message }}</div>

<!-- 透過 JavaScript Expression 綁定資料 // 根據 ok 的值(true or false)對應不同的輸出值 -->
<div>{{ ok ? 'Yes' : 'No' }}</div>

<!-- 根據score的值綁定不同的 key -->
<div>{{ score>=60 ? goodMsg : badMsg }}</div>

<!-- 也可作數學運算或字串合併 -->
<div>{{ number + 1 }}</div>
<div v-bind:id="'list' + id"></div>
```

### Dynamic Arguments

透過 JavaScript Expression 綁定動態參數，**建議採小寫命名**，適用各種情況。

```html
<a v-bind:[attributename]="url">...</a>
<!-- 當attributename= href，相當於 v-bind:href="url" -->
```

當使用在 in-DOM templates ( templates 直接寫在 HTML file 內)，key 的命名應避免內含大寫字母，因為瀏覽器會強迫將它改成小寫。

```html
<a v-on:[someAttr]="doSomething">...</a>
<!-- 因為會被改為v-on:[someattr]="doSomething"，此時： -->
```

```js
data: {
  someAttr: 'click'; // error
  someattr: 'click'; // success
}
```

### 縮寫

- `v-bind`

```html
<!-- full syntax -->
<a v-bind:href="url"> ... </a>

<!-- shorthand -->
<a :href="url"> ... </a>

<!-- shorthand with dynamic argument (2.6.0+) -->
<a :[key]="url"> ... </a>
```

- `v-on`

```html
<!-- full syntax -->
<a v-on:click="doSomething"> ... </a>

<!-- shorthand -->
<a @click="doSomething"> ... </a>

<!-- shorthand with dynamic argument (2.6.0+) -->
<a @[event]="doSomething"> ... </a>
```

# Computed Properties and Watchers

---

## Computed Properties

在 template 內使用 JavaScript Expression 雖然很方便，但使用太多造成不易維護，因此應該使用 **computed property** 處理任何複雜的邏輯運算。

```html
<div>{{ score>=60 ? 'good' : 'bad' }}</div>
應改為
<div>{{ result }}</div>
```

```js
data: {
  score: 80
},
computed: {
  result: function(){
    return this.score>=60 ? 'good' : 'bad';
  }
}
```

### computed properties vs methods

- **computed properties** 會因與它連動的資料(如上例的 score )有變動而自動更新，但如果 score 不變，result 也不會更新，且無法自帶任何參數。
- **methods** 會在重新渲染時執行

### Computed vs Watched Property

Vue 提供一個更通用的方式去觀察與反應資料的變動：`watch` ，但有時使用 watch 會造成類似的程式碼重複，此時應改而使用 `computed`

```html
<div>{{ fullName }}</div>
```

```js
data: {
  firstName: 'Peter',
  lastName: 'Jacson',
  fullName: 'Peter Jacson'
},
watch: {
  firstName: function(val){
    this.fullName = val + ' ' + this.lastName
  },
  lastName: function(val){
    this.fullName = this.firstName + ' ' + val
  }
}
```

```js
// 應改為
data: {
  firstName: 'Peter',
  lastName: 'Jacson'
},
computed: {
  fullName: function(){
    return this.firstName + ' ' + this.lastName;
  }
}
```

### Computed Setter

上例的 fullName() 是使用 computed property 預設的 getter-only，相當於以下寫法：

```js
computed: {
  fullName: {
    // getter
    get: function(){
      return this.firstName + ' ' + this.lastName;
    }
  }
}
```

你也可以自行加入 setter，如下：

```js
computed: {
  fullName: {
    // getter
    get: function(){
      return this.firstName + ' ' + this.lastName;
    },
    // setter
    set: function(newFullName){
      const names = newFullName.split(' ');
      this.firstName = names [0];
      this.lastName = names[names.length - 1];
    }

  }
}
```

現在可以使用 `vm.fullName = 'John Doe'` 同時更新 `vm.firstName` 與 `vm.lastName`

## Watchers

`computed` 適用於絕大部份情況，但有些非同步或複雜的操作更適合使用 `watch`，見[官網範例](https://vuejs.org/v2/guide/computed.html#Watchers)。

# 綁定 Class and Style

---

當使用 `v-bind` 綁定的是 `class` 或 `style` 時，值除了字串外，也可以是 array or object

## 綁定 class

- object 語法：只有在 key 值為 true 時，才會使用該 key 命名 class

```html
<div v-bind:class={ active: isActive }>...</div>
```

```js
data: {
  isActive: true;
}
```

- 可以綁定多個 class

```html
<div class="static" v-bind:class="{ active: isActive, 'text-danger': hasError }"></div>
```

```js
data: {
  isActive: true,
  hasError: false
}
```

- **更為常見且有用的作法是使用 `computed` 回傳 class object**

```html
<div class="static" v-bind:class="classObject"></div>
```

```js
data: {
  isActive: true,
  error: null
},
computed: {
  classObject: function(){
    return {
      active: this.isActive && !this.error,
      'text-dange': this.error && this.error.type !== 'fatal'
      'text-danger fatal': this.error && this.error.type === 'fatal'
    }
  }
}
```

- array 語法

```html
<!-- 套用 class 清單 -->
<div v-bind:class="[activeClass, errorClass]">...</div>
```

```js
data: {
  activeClass: 'active italic',
  errorClass: 'text-danger underline'
}
```

```html
<!-- 在 array 內使用條件判斷 -->
<div v-bind:class="[isActive ? activeClass : '', errorClass]">...</div>
```

```js
data: {
  isActive: true,
  activeClass: 'active italic',
  errorClass: 'text-danger underline'
}
```

```html
<!-- 當 array 內有多個條件判斷時， array 會變得冗長，此時結合 array + object 語法 -->
<div
  v-bind:class="[
  {'active show': isActive}, 
  {'text-danger underline': hasError},
  ...
  ]"
>
  ...
</div>
```

- 在組件上綁定 class 時，所綁定的 class 會套用在組件的 **root element**

```html
<my-component v-bind:class="[activeClass]"></my-component>
```

```js
Vue.component('my-component',{
  template: '<div class="bold"><p>Hello</p></div>'
};
const vm = new Vue({
  el: '#app',
  data: {
    activeClass: 'italic underline'
  }
});
```

結果：

```html
<div class="bold italic underline"><p>Hello</p></div>
```

## 綁定 inline style

- object 語法：與撰寫 css 類似，但它本質上是一個 JavaScript object，可使用 **camelCase** 或 **kebab-case** 命名 CSS property names。

```html
<div v-bind:style="{fontSize: size + 'px', 'text-decoration': textDecoration}">...</div>
```

```js
data: {
  size: 20,
  textDecoration: 'underline'
}
```

**更常用的是以 style object 取代上述綁定 style 的方式，可以讓 template 更簡潔。**

```html
<div v-bind:style="myStyle">...</div>
```

```js
data: {
  myStyle: {
    size: '20px',
    textDecoration: 'underline'
  }
}
```

- array 語法，可同時綁定多個 style object，樣式可以覆蓋。

```html
<div v-bind:style="[baseStyles, overridingStyles]">...</div>
```

```js
data: {
  baseStyles: {
    fontSize: '20px',
    color: 'red'
  },
  overridingStyles: {
    color: 'blue'
  }
}
```

- Auto-prefixing：當 `v-bind:style` 綁定的 property 需要 `vendor prefixes`，例如：`transform`，Vue 會自動偵測瀏覽器而補上適合的 prefixes。
- Multiple Values：對同一個 style property 提供多值時(以 array 表示)，Vue 只會採用該瀏覽器能支援的最後一個值

```html
<div v-bind:style="{display: ['-webkit-box', '-ms-flexbox', 'flex']}">...</div>
<!-- Chrome 會顯示 style="display: flex" -->
```

# Conditional Rendering

---

## `v-if`

Controlling Reusable Elements with key

```html
<template v-if="loginType === 'username'">
  <label>Username</label>
  <input type="text" placehlder="enter your name" />
</template>
<template v-else>
  <label>Email</label>
  <input type="email" placehlder="enter your email" />
</template>
<p><button v-on:click="toggle()">Toggle Login Type</button></p>
<!-- 當 input 內有輸入值，按下 button 切換 login type時會保留其值，因為這2個 template 共用相同元素 -->
```

```html
<!-- 如果希望這2個 template 的 input 是分開不共用的，可各自指定唯一的 key，
如此在切換 login type 時，input 已輸入的值也會被清除；但由於<label>並未指定唯一的 key ，
所以如果這2個 template 的<label>...</label>結構相同的話，仍會共用該元素。 -->
<template v-if="loginType === 'username'">
  <label>Username</label>
  <input type="text" placehlder="enter your name" key="key1" />
</template>
<template v-else>
  <label>Email</label>
  <input type="email" placehlder="enter your email" key="key2" />
</template>
<p><button v-on:click="toggle()">Toggle Login Type</button></p>
```

## `v-show`

用法與 `v-if` 類似，但 DOM 會一直存在於頁面，只透過 `style="display:block | none"` 決定是否顯示，但不可用於 `<template>` 這個元素，也無法與 `v-else` 搭配。

## `v-if` vs `v-show`

- `v-if` 是真正的條件渲染，可以確保指定的 DOM 元素被移除或重新產生於頁面
- `v-show` 所作用的 DOM 元素會一直存在頁面上，只透過 `style="display:block | none"` 決定是否顯示
- `v-show` 適用於需要頻繁切換的 DOM 元素，反之使用 `v-if`

## `v-if` with `v-for`

**不建議對同一個 DOM 元素同時使用 `v-if` 與 `v-for`；當同時使用時，`v-for` 有較高的優先權。**

```html
<!-- 要顯示尚未完成的 todo -->
<!-- 由於 v-for 有較高優先權，所以仍會先執行所有 todo，再依 v-if 過濾，也就是說無法降低迴圈的執行次數 -->
<ul>
  <li v-if="!todo.done" v-for="todo in todos" v-bind:key="todo.id">{{todo.name}}</li>
</ul>
```

```js
data: {
  todos: [
    {
      id: 1,
      name: 'learning js',
      done: false
    },
    {
      id: 2,
      name: 'learning vue',
      done: true
    }
  ];
}
```

上例應先使用 `computed` 過濾 todos 產生新資料 pendingTodos，再使用 `v-for` 對應新資料

```html
<ul>
  <li v-for="todo in pendingTodos">{{todo.name}}</li>
</ul>
```

```js
data: {
    todos: [{
      id: 1,
      name: 'learning js',
      done: false
    }, {
      id: 2,
      name: 'learning vue',
      done: true
    }]
  },
computed: {
  pendingTodos() {
    return this.todos.filter(todo => {
      return !todo.done
    })
  }
}
```

# List Rendering (Array, Object)

---

## Mapping an Array to Elements with `v-for`

```js
data: {
  list: ['learning JS', 'learning Vue'];
}
```

```html
<!-- 一般寫法 -->
<ul>
  <li v-for="item in list">{{item}}</li>
</ul>
```

```html
<!-- v-for 可接受第2組參數 index, 也可以用 of 取代 in -->
<ul>
  <li v-for="(item, index) in list">{{index}}-{{item}}</li>
</ul>
```

結果：

- 0-learning JS
- 1-learning Vue

## `v-for` with an Object

```js
data: {
    article: {
      title: 'How to do lists in Vue',
      author: 'Jane Doe',
      publishedAt: '2016-04-10'
    }
 }
```

```html
<!-- 一般寫法 -->
<ul>
  <li v-for="value in article">{{value}}</li>
</ul>
```

結果：

- How to do lists in Vue
- Jane Doe
- 2016-04-10

```html
<!-- v-for 可接受第2, 3組參數，分別為 key, index -->
<div v-for="(value, key, index) in article">
  {{index}}.{{key}}: {{value}}
</div>
```

結果：
1.title: How to do lists in Vue
2.author: Jane Doe
3.publishedAt: 2016-04-10

## 注意事項

### Array 的狀態變化

由於 JavaScript 的限制，Vue 無法即時偵測下列 2 種操作的 Array 狀態變化：

1. 直接使用 index 改變 array 的內容，e.g. `vm.items[1] = 'x'`
1. 直接修改 array 的長度，e.g. `vm.items.length = 2`

```js
// 目標是把 'b' 換成 'x'，並且只保留前2個值
var vm = new Vue({
  data: {
    items: ['a', 'b', 'c', 'd']
  }
});
vm.items[1] = 'x'; // is NOT reactive
vm.items.length = 2; // is NOT reactive
```

==1. 的解法：==

```js
// Vue.set(array, index, newValue)
Vue.set(vm.items, 1, 'x');

// vm.$set(array, index, newValue)
vm.$set(vm.items, 1, 'x');

// Array.prototype.splice, array.splice(start, howmany, newValue)
vm.items.splice(1, 1, 'x');
```

==2. 的解法：==

```js
// vm.items.splice(newLength)
vm.items.splice(2);
```

### Object 的狀態變化

由於 JavaScript 的限制，Vue 可以偵測屬性的修改，但無法偵測屬性的**新增**與**刪除**，更不允許在 Vue instance 動態新增一個 **root-level** 互動屬性(e.g. `vm.b=1` )，但可以在 nested object 使用 Vue 的方法(e.g. `Vue.set()` 或 `vm.$set()`)或利用**合併物件**的方式( `Object.assign()` )新增屬性：

```js
const vm = new Vue({
  el: '#app',
  data: {
    user: {
      name: 'Peter'
    }
  }
}
vm.user.name = 'Joe'; // modification is now reactive
vm.b = 1; // addition in root-level is NOT reactive

vm.user.age = 20; // is NOT reactive

// Vue.set(object, propertyName, value)
Vue.set(vm.user, 'age', 20); // is now reactive
// or
// vm.$set(object, propertyName, value)
vm.$set(vm.user, 'age', 20); // is now reactive

// 有時需要對現有的物件新增很多屬性
vm.user = Object.assign({}, vm.user, {
  age: 20,
  sex: 'male'
}); // is now reactive
```

## 顯示過濾或排序的結果

有時不想直接顯示原始資料，而要顯示過濾或排序之後的資料，可以使用 `computed property` 或 `methods` :

- 使用 computed property

```html
<ul>
  <li v-for="n in evenNumbers">{{ n }}</li>
</ul>
```

```js
data: {
  numbers: [1,2,3,4,5]
},
computed: {
  evenNumbers: function(){
    return this.numbers.filter(function(n){
      return n % 2 === 0;
    })
  }
}
```

- 使用 methods

```html
<ul>
  <li v-for="n in even(numbers)">{{ n }}</li>
</ul>
```

```js
data: {
  numbers: [1,2,3,4,5]
},
methods: {
  even: function(ary){
    return ary.filter(function(n){
      return n % 2 === 0;
    })
  }
}
```

## `v-for` with a Range

`v-for` 可指定一個整數，做為 template 重複執行的次數

```html
<div>
  <span v-for="n in 10">{{ n }}</span>
</div>
<!-- 結果：12345678910 -->
```

## `v-for` on a `<template>`

```html
<ul>
  <template v-for="item in list">
    <li>{{ item }}</li>
    <li>-------------------</li>
  </template>
</ul>
```

## `v-for` with `v-if`

**不建議對同一個 DOM 元素同時使用 `v-if` 與 `v-for`；當同時使用時，`v-for` 有較高的優先權。**

```html
<!-- 要顯示尚未完成的 todo -->
<!-- 由於 v-for 有較高優先權，所以仍會先執行所有 todo，再依 v-if 過濾，也就是說無法降低迴圈的執行次數 -->
<ul>
  <li v-if="!todo.done" v-for="todo in todos" v-bind:key="todo.id">{{todo.name}}</li>
</ul>
```

```js
data: {
  todos: [
    {
      id: 1,
      name: 'learning js',
      done: false
    },
    {
      id: 2,
      name: 'learning vue',
      done: true
    }
  ];
}
```

上例應先使用 `computed` 過濾 todos 產生新資料 pendingTodos，再使用 `v-for` 對應新資料

```html
<ul>
  <li v-for="todo in pendingTodos">{{todo.name}}</li>
</ul>
```

```js
data: {
    todos: [{
      id: 1,
      name: 'learning js',
      done: false
    }, {
      id: 2,
      name: 'learning vue',
      done: true
    }]
  },
computed: {
  pendingTodos() {
    return this.todos.filter(todo => {
      return !todo.done
    })
  }
}
```

## `v-for` with a Component

在 component 上面使用 `v-for` 時，必須綁定 `key`，以下範例是使用 component 建立一個 todo list：

```html
<div id="app">
  <form v-on:submit.prevent="addNewTodo">
    <label for="newTodo">New Todo:</label>
    <input id="newTodo" placeholder="e.g. learning Vue" v-model="newTodoText" />
    <button>Add</button>
  </form>
  <ul v-if="todos.length">
    <todo-item
      v-for="(todo, index) in todos"
      v-bind:key="todo.id"
      v-bind:title="todo.title"
      v-on:remove="removeTodo(index)"
    ></todo-item>
  </ul>
  <p v-else>Todo list is empty now.</p>
</div>
```

```js
Vue.component('todo-item', {
  template: `
	<li>
		<button v-on:click="$emit('remove')">Remove</button>
		{{ title }}
	</li>
	`,
  props: ['title']
});

const vm = new Vue({
  el: '#app',
  data: {
    todos: [
      {
        id: 1,
        title: 'learning js'
      },
      {
        id: 2,
        title: 'learning Vue'
      },
      {
        id: 3,
        title: 'building a template'
      }
    ],
    nextTodoId: 4,
    newTodoText: ''
  },
  methods: {
    addNewTodo: function() {
      if (this.newTodoText.length) {
        this.todos.push({
          id: this.nexTodoId++,
          title: this.newTodoText
        });
        this.newTodoText = '';
      } else {
        console.log('欄位不可空白');
      }
    },
    removeTodo: function(index) {
      this.todos.splice(index, 1);
    }
  }
});
```

# 事件處理

---

## Methods in Inline Handlers

一般用法，若無參數則只須寫 function name，e.g. `v-on:click="say"`

```html
<button v-on:click="say('hello')">Greeting</button>
```

```js
methods: {
	say: function(message){
		alert(message);
	}
}
```

有時需要存取原生 DOM 元素，可傳入 `$event` 作為最後一組參數(雖可省略，但仍建議寫上以便閱讀，除非沒有其他參數需要傳遞)

```html
<button v-on:click="sayHi">Say Hi</button> <button v-on:click="say('Hello', $event)">Say</button>
```

```js
methods: {
	sayHi: function(){
		alert('Hi');
		if(event)
			alert(event.target.tagName);
	},
	say: function(message, event){
		alert(message);
		if(event)
			alert(event.target.tagName);
	}
}
```

## Event Modifiers

在事件處理函式內常常需要加上 `event.preventDeafult()` or `event.stopPropagation()`，雖然可以直接寫在 Vue 的 `methods` 內，但為了讓這些 `methods` 可以單純的處理資料邏輯，Vue 針對 `v-on` 提供了 `event modifiers`：

- `.stop`
- `.prevent`
- `.capture`
- `.self`
- `.once`
- `.passive`

```js
methods:{
    whoami(event){
        console.log(`${event.target.tagName}-${event.currentTarget.tagName}`)
    }
}
```

```html
<!-- the click event's propagation will be stopped -->
<!-- output: "SPAN-SPAN"  "SPAN-A"-->
<a v-on:click.stop="whoami">
  <span v-on:click="whoami">Click</span>
</a>

<!-- use capture mode when adding the event listener -->
<!-- output: "SPAN-A"  "SPAN-SPAN" -->
<a v-on:click.capture="whoami">
  <span v-on:click="whoami">Click</span>
</a>

<!-- only trigger handler if event.target is the element itself -->
<!-- .self 要放在 parent element -->
<!-- output: "SPAN-SPAN" -->
<a v-on:click.self="whoami">
  <span v-on:click="whoami">Click</span>
</a>

<!-- the submit event will no longer reload the page -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- just the modifier -->
<form v-on:submit.prevent></form>

<!-- modifiers can be chained -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- the click event will be triggered at most once -->
<!-- 有別於其他 modifiers 只能用在原生 DOM 元素，.once 也可用於 component events -->
<a v-on:click.once="doThis"></a>

<!-- .passive 對應到 addEventListener 的 passive 選項，對於改善行動裝置的效能特別有用 -->
<!-- the scroll event's default behavior (scrolling) will happen immediately, 
instead of waiting for `onScroll` to complete if it contains `event.preventDefault()`-->
<div v-on:scroll.passive="onScroll">...</div>
```

> modifiers 串連時的順序也會影響執行的結果，例如：使用 `v-on:click.prevent.self`會影響所有的 click，但是 `v-on:click.self.prevent` 只會影響 element 本身。

## Key Modifiers

監聽鍵盤事件時，通常會檢查特定的按鍵。

```html
<!-- 當按下 'Enter' 鍵時，會呼叫 'vm.submit()' -->
<input v-on:keyup.enter="submit" />
```

你可以透過 `KeyboardEvent.key` 指定任何合法的按鍵名稱(使用 kebab-case )作為 modifiers

```html
<input v-on:keyup.page-down="onPageDown" />
```

> Vue 雖然不推薦使用 `keyCode` ，但仍允許使用。

```html
<!-- 'Enter' 的 keyCode: 13 -->
<input v-on:keyup.13="submit" />
```

Vue 針對最常用的按鍵提供了別名：

- `.enter`
- `.tab`
- `.delete` (包含 "Delete" and "Backspace" keys)
- `.esc`
- `.space`
- `.up`
- `.down`
- `.left`
- `.right`

> 有些 keys (`.esc`, `.up`, `.down`, `.left`, `.right`)在 IE9 的 keyCode 與其他瀏覽器不一致，所以最好使用內建的別名，由 Vue 解決 keyCode 不一致的問題。

你也可以通過全域的 `Vue.config.keyCodes` 自訂按鍵別名

```js
// enable `v-on:keyup.f1`
Vue.config.keyCodes.f1 = 112;
```

## System Modifier Keys

你可以使用下列 modifiers 在對應按鍵被按下時觸發滑鼠或鍵盤的事件監聽器

- `.ctrl`
- `.shift`
- `.alt`
- `.meta` (macOS: ⌘, windows: ⊞)

```html
<!-- Alt + C -->
<input v-on:keyup.alt.c="clear" />

<!-- Ctrl + Click -->
<div v-on:click.ctrl="doSomething">Do something</div>
```

> 當使用在 `keyup` event 時，有別於 regular keys，System Modifier Keys 無法單獨使用而必須搭配其他按鍵，例如： `v-on:keyup.ctrl` 只有在按住 `ctrl` 時釋放其他按鍵才會觸發事件，只是單獨釋放 `ctrl` 並不會觸發；如果想要單獨釋放 `ctrl` 時觸發事件，要使用 keyCode(`v-on:keyup.17`)而非別名(`v-on:keyup.ctrl`)。

### `.exact` Modifier

`.exact`需要精確的 System modifier keys 的結合才會觸發事件。

```html
<!-- 即便 Alt or Shift 被按下也會執行 -->
<button v-on:click.ctrl="onClick">A</button>

<!-- 只有在 Ctrl + Click 且沒有按下其他 System Modifier Keys 的情況下才會執行 -->
<button v-on:click.ctrl.exact="onCtrlClick">A</button>

<!-- 只有單獨 Click 且沒有按下其他 System Modifier Keys 的情況下才會執行 -->
<button v-on:click.exact="onClick">A</button>
```

### Mouse Button Modifiers

- `.left`
- `.right`
- `.middle`

# 表單輸入綁定

---

## 基礎用法

`v-model` 可以對表單元件( `<input>`, `<select>`, `<textarea>`)建立雙向資料綁定，它會根據表單元件的類型自動選擇正確的方式更新元素，但會忽略該表單元件的 `value`, `checked`, `selected` 屬性值，你應該使用 JavaScript 在組件的 `data` 選項內宣告初始值。

`v-model`對不同的輸入元件綁定不同的 `attribute`^1^並拋出不同的 `event`^2^：

- `text, textarea`: `value`^1^, `input`^2^
- `checkbox, radio`: `checked`^1^, `change`^2^
- `<select>`: `value`^1^, `change`^2^

### `text`, `textarea`

```html
<!-- input type="text" -->
<input type="text" v-model="message" placeholder="edit me" />
<p>Message is: {{ message1 }}</p>

<!-- textarea -->
<textarea v-model="message2" placeholder="edit me"></textarea>
<div>
  Message is:
  <p style="white-space: pre-line">{{ message2 }}</p>
</div>
```

```js
data: {
  message1: '', // 宣告初始值
  message2: ''  // 宣告初始值
}
```

### `checkbox`, `radio`

- checkbox: 單選，綁定單一 data (Boolean)

```html
<input type="checkbox" v-model="isAgree" id="agreement" />
<label for="agreement">{{isAgree}}</label>
```

```js
data: {
  isAgree: false; // 宣告初始值
}
```

- checkbox: 複選，綁定到同一個 data (Array)

```html
<label><input type="checkbox" value="A" v-model="checkedItems" />AAA</label>
<label><input type="checkbox" value="B" v-model="checkedItems" />BBB</label>
<label><input type="checkbox" value="C" v-model="checkedItems" />CCC</label>
<p>Selected: {{checkedItems}}</p>
```

```js
data: {
  checkedItems: ['B']; // 宣告初始值，此時 value = 'B' 的選項為 checked
}
```

- radio: 多選一，綁定單一 data (String)

```html
<label><input type="radio" value="A" v-model="picked" name="group" />AAA</label>
<label><input type="radio" value="B" v-model="picked" name="group" />BBB</label>
<label><input type="radio" value="C" v-model="picked" name="group" />CCC</label>
<p>Selected: {{picked}}</p>
```

```js
data: {
  picked: 'B'; // 宣告初始值，此時 value = 'B' 的選項為 checked
}
```

### `<select>`

- 單選，綁定單一 data (String)

```html
<select v-model="singleSelect">
  <option value="" disabled>Select One</option>
  <option value="A">AAA</option>
  <option value="B">BBB</option>
  <option value="C">CCC</option>
</select>
<p>Selected: {{singleSelect}}</p>
```

```js
data: {
  singleSelect: ''; // 宣告初始值
}
```

> 如果 `v-model`的值無法匹配任一選項，`<select>`將會處在"未選中"的空白狀態，在 iOS 中，會讓用戶無法選擇第一個選項而導致無法觸發 change event，因此建議提供一個"空值禁用"的選項。(如上例：`<option value="" disabled>Select One</option>`)

- 複選，綁定到同一個 data (Array)

```html
<select v-model="multipleSelects" multiple>
  <option value="A">AAA</option>
  <option value="B">BBB</option>
  <option value="C">CCC</option>
</select>
<p>Selected: {{multipleSelects}}</p>
```

```js
data: {
  multipleSelects: ['B']; // 宣告初始值，此時 value = 'B' 的選項為 selected
}
```

- 與 `v-for`結合使用

```html
<select v-model="selected">
  <option v-for="option in options" v-bind:value="option.value" v-bind:disabled="option.disabled">
    {{option.text}}
  </option>
</select>
<p>Selected: {{selected}}</p>
```

```js
data: {
  selected: 'B', // 宣告初始值，此時 value = 'B' 的選項為 selected
}
  options: [
    { value: '', text: 'Select One', disabled: true},
    { value: 'A', text: 'AAA', disabled: false},
    { value: 'B', text: 'BBB', disabled: false},
    { value: 'C', text: 'CCC', disabled: false}
  ]
}
```

## 值綁定

對於`checkbox` `radio` `select option`, `v-model`綁定的值通常是靜態字串或布林值。

- `checkbox`

```html
<!-- vm.toggle = true or false (Boolean) -->
<input type="checkbox" v-model="toggle" />

<!-- vm.toggle = 'yes' or 'no' -->
<input type="checkbox" v-model="toggle" true-value="yes" false-value="no" />
```

> 這裡的 `true-value`, `false-value`並不會影響表單元件的 `value`屬性

- `radio`

```html
<!-- 當第一個被選中時，vm.picked = 'A' (Static String) -->
<input type="radio" name="group" v-model="picked" value="A" />
<input type="radio" name="group" v-model="picked" value="B" />

<!-- 當第一個被選中時，vm.picked === vm.mySel.a -->
<input type="radio" name="group" v-model="picked" v-bind:value="mySel.a" />
<input type="radio" name="group" v-model="picked" v-bind:value="mySel.b" />
```

```js
data: {
  picked: 1,
  mySel: {
    a: 1,
    b: 2
  }
}
```

- `select option`

```html
<!-- 當第一個選項被選中時，vm.selected = 'A' -->
<select v-model="selected">
  <option value="A">AAA</option>
  <option value="B">BBB</option>
  <option value="C">CCC</option>
</select>

<!-- 當第一個選項被選中時，typeof vm.selected = 'object', vm.selected.num = 123 -->
<select v-model="selected">
  <option v-bind:value="{num: 123}">AAA</option>
  <option value="B">BBB</option>
  <option value="C">CCC</option>
</select>
```

## 修飾符

### `.lazy`

在預設情況下，`v-model`會在每次`input`事件觸發時同步更新輸入框的值與數據。使用`.lazy`可將觸發事件由`input`改為`change`

```html
<!-- 資料會在`change`時更新，而非`input` -->
<input type="text" v-model.lazy="msg" />
<p>{{ msg }}</p>
```

### `.number`

自動將使用者輸入的值轉為數字型態

```html
<input type="number" v-model.number="age" />
<p>{{typeof age}}: {{age}}</p>
```

> 這通常很有用，因為即便是 `type="number"`，該表單元件回傳的值也是字串型態，如果無法被`parseFloat()`解析，則會回傳原始值。

### `.trim`

自動過濾使用者輸入的首尾空白字元

```html
<input type="text" v-model.trim="msg" />
<p style="white-space: pre">{{msg}}</p>
```

# 組件基礎

---

## 基本例子

```js
// 以全域註冊的方式，定義一個名為 button-counter 的組件
Vue.component('button-counter', {
  // 組件的 data 必須是一個函數
  data: function() {
    return {
      count: 0
    };
  },
  template: '<button v-on:click="count++">You clicked me {{count}} times</button>'
});
```

```html
<div id="app">
  <!-- 組件可重複使用，內部的 count 各自獨立 -->
  <button-counter></button-counter>
  <button-counter></button-counter>
</div>
```

## 通過 props 向子組件傳遞資料

```js
Vue.component('blog-post', {
  props: ['title'],
  template: '<h3>{{ title }}</h3>'
});

new Vue({
  el: '#app',
  data: {
    posts: [
      { id: 1, title: 'My journey with Vue' },
      { id: 2, title: 'Blogging with Vue' },
      { id: 3, title: 'Why Vue is so fun' }
    ]
  }
});
```

```html
<div id="app">
  <!-- 為每一篇文章渲染組件 -->
  <blog-post v-for="post in posts" v-bind:key="post.id" v-bind:title="post.title"></blog-post>
  <!-- 不使用 v-bind:title 而直接使用 title 時，可自行輸入資料 -->
  <blog-post title="This is static title"></blog-post>
</div>
```

## 單一根元素

**每個組件只能有一個根元素**，否則 Vue 會顯示錯誤。

```js
template: '<h3>{{title}}</h3><div v-html="content"></div>'; // error
template: '<div><h3>{{title}}</h3><div v-html="content"></div></div>'; // correct
```

當組件很複雜時，如果還要一一綁定 `prop` 會很麻煩，此時可將所有需要綁定的資料集中在單一 `prop`

```html
<blog-post
  v-for="post in posts"
  v-bind:key="post.id"
  v-bind:title="post.title"
  v-bind:content="post.content"
  v-bind:publishedAt="post.publishedAt"
></blog-post>
```

```html
<!-- 重新解構組件，當 post 有新屬性(例如：comments)時，可自動在組件內使用 -->
<blog-post v-for="post in posts" v-bind:key="post.id" v-bind:post="post"></blog-post>
```

```js
Vue.component('blog-post', {
  props: ['post'],
  template: `
  <div class="blog-post">
    <h3>{{ post.title}}</h3>
    <div v-html="post.content"></div>
    <div>published: {{ post.publishedAt }}, comments: {{ post.comments}}</div>
  </div>
  `
});

new Vue({
  el: '#app',
  data: {
    posts: [
      { id: 1, title: 'My journey with Vue', content: '...', publishedAt: '...', comments: 12 },
      { id: 2, title: 'Blogging with Vue', content: '...', publishedAt: '...', comments: 10 },
      { id: 3, title: 'Why Vue is so fun', content: '...', publishedAt: '...', comments: 8 }
    ]
  }
});
```

## 監聽子組件事件

利用子組件內建的 `$emit(eventName)` 可向父組件傳遞一個事件，由父組件決定該事件觸發時要執行什麼函式。
例如：上例要新增一個放大字級的按鈕

```js
Vue.component('blog-post', {
  ...
  // 為新增的 button 綁定 click 時向父組件傳遞一個名為 'enlarte-text' 的事件
  template: `...<button v-on:click="$emit('enlarge-text')">Enlarge Text</button>`
})

new Vue({
  el: '#app',
  data: {
    ...
    postFontSize: 1 // 新增預設字級
  },
  methods: {
    onEnlargeText(){
      this.postFontSize += 0.1;
    }
  }
})
```

```html
<!-- 在父組件綁定 style，同時接收子組件傳遞的事件 -->
<div id="app" :style="{fontSize: postFontSize + 'em'}">
  <!-- 使用函式處理 -->
  <blog-post v-on:enlarge-text="onEnlargeText" ...></blog-post>
</div>
```

### 使用`event`拋出一個值

上例組件的 `<blog-post>` 如果要拋出一個特定值來指定放大的字級，可在 `$emit` 加入第 2 個參數：

```js
Vue.component('blog-post', {
  ...
  template: `...<button v-on:click="$emit('enlarge-text', 0.2)">Enlarge Text</button>`
})

...
methods: {
    // 第一個參數即為子組件拋出的值
    onEnlargeText(value){
      this.postFontSize += value;
    }
  }
```

```html
<div id="app" :style="{fontSize: postFontSize + 'em'}">
  <!-- 使用函式處理 -->
  <blog-post v-on:enlarge-text="onEnlargeText" ...></blog-post>
  <!-- 直接使用 $event 代表子組件拋出的值 -->
  <blog-post v-on:enlarge-text="postFontSize += $event" ...></blog-post>
</div>
```

### 組件上使用`v-model`

```html
<!-- v-model 的一般用法 -->
<input v-model="searchText" />

<!-- 其實相當於下面語法：在觸發 input 事件時，更新已綁定的 value  -->
<input v-bind:value="searchText" v-on:input="searchText = $event.target.value" />
```

將這樣的觀念應用在組件內的`<input>`：

- 綁定 `value` 屬性
- 組件需要向外層拋出`input`的事件及傳遞`value`的值

```js
Vue.component('my-input', {
  props: ['searchText'],
  template: `
  <div>
    Keywords: 
    <input type="text" placeholder="search something..."
      :value="searchText" 
      @input="$emit(\'input\', $event.target.value)">
  </div>
  `
});

new Vue({
  el: '#app',
  data: {
    searchText: ''
  }
});
```

```html
<div id="app">
  <my-input v-model="searchText"></my-input>
  <!-- 相當於下面語法 -->
  <my-input v-bind:searchText="searchText" v-on:input="searchText = $event"></my-input>

  <p>Your keywords is {{ searchText }}</p>
</div>
```

## 使用`<slot>`傳遞內容

和 HTML tag 一樣，可以在組件 tag 之間傳遞內容

```html
<alert-box>
  Something bad happened.
</alert-box>
```

```js
// 只要在需要的地方加入插槽 slot 就行了
Vue.component('alert-box', {
  template: `
    <div>
      <strong>Error!</strong>
      <slot></slot>
    </div>
  `
});
```

## 動態組件

使用`<component v-bind:is="組件名稱"></component>`，只要動態變更**組件名稱**即可達成。

```html
<div id="app">
  <ul>
    <li v-for="tab in tabs" :key="tab.id" @click="onTabClick(tab.componentName)">{{tab.text}}</li>
  </ul>
  <component :is="currentTabContent"></component>
</div>
```

```js
Vue.component('c1', {
  template: '<div>This is the content of Home.</div>'
});

Vue.component('c2', {
  template: '<div>This is the content of Posts.</div>'
});

Vue.component('c3', {
  template: '<div>This is the content of Archive.</div>'
});

new Vue({
  el: '#app',
  data: {
    tabs: [
      { id: 1, text: 'Home', componentName: 'c1' },
      { id: 2, text: 'Posts', componentName: 'c2' },
      { id: 3, text: 'Archive', componentName: 'c3' }
    ],
    currentTabContent: 'c1'
  },
  methods: {
    onTabClick(name) {
      this.currentTabContent = name;
    }
  }
});
```

## 解析 DOM Template 時的注意事項

有些 HTML 元素只能出現在特定元素內，例如： `<ul><li>`, `<select><option>`, `<table><transition>`，這會導致 Vue 在解析 DOM Template 時出現問題：

```html
<table>
  <!-- 組件 <blog-post-row> 會被視為無效內容而提升到 table 外部 -->
  <blog-post-row></blog-post-row>
</table>

<!-- 相當於 -->
<blog-post-row></blog-post-row>
<table></table>
```

要修正這樣的問題，可使用 `is` 這個特殊的 attribute

```html
<table>
  <tr is="blog-post-row"></tr>
</table>
```

需要注意的是如果我們從以下來源使用 Template，這條限制是不存在的：

- 字符串，(e.g. `` template: `...` ``)
- 單文件組件 (.vue)
- `<script type="text/x-template">`
